{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Samarium Samarium is a dynamic interpreted language transpiled to Python. Samarium, in its most basic form, doesn't use any digits or letters. Here's a Hello, World! program written in Samarium: => * { \"Hello, World!\"!; } Installation pip pip install samarium AUR git clone https://aur.archlinux.org/samarium.git; cd samarium; makepkg -sirc or use your favorite AUR helper . Using Samarium You can run Samarium programs with samarium program.sm . samarium-debug may be used instead, which will first print out the intermediary Python code that the Samarium program is transpiled into, before executing it. Short Long Description -c <cmd> --command <cmd> Can be used to execute Samarium code from the string cmd , directly in the terminal. cmd can be one or more statements separated by semicolons as usual. Note that the last statement of cmd will be printed if it does not end in a semicolon. -h --help Shows the help message -v --version Prints Samarium version There is also a VSCode syntax highlighting extension for Samarium, which can be found here here . Its source code can be found here . Credits Samarium was inspired by several languages, including brainfuck , Rust , Python and Java . Special thanks to: tetraxile for helping with design choices and writing the docs MithicSpirit for making an AUR package for Samarium DarviL82 for fixing some issues Endercheif for making the documentation look fancy and helping with design choices If you have any questions, or would like to get in touch, join the Discord server !","title":"Home"},{"location":"#samarium","text":"Samarium is a dynamic interpreted language transpiled to Python. Samarium, in its most basic form, doesn't use any digits or letters. Here's a Hello, World! program written in Samarium: => * { \"Hello, World!\"!; }","title":"Samarium"},{"location":"#installation","text":"","title":"Installation"},{"location":"#pip","text":"pip install samarium","title":"pip"},{"location":"#aur","text":"git clone https://aur.archlinux.org/samarium.git; cd samarium; makepkg -sirc or use your favorite AUR helper .","title":"AUR"},{"location":"#using-samarium","text":"You can run Samarium programs with samarium program.sm . samarium-debug may be used instead, which will first print out the intermediary Python code that the Samarium program is transpiled into, before executing it. Short Long Description -c <cmd> --command <cmd> Can be used to execute Samarium code from the string cmd , directly in the terminal. cmd can be one or more statements separated by semicolons as usual. Note that the last statement of cmd will be printed if it does not end in a semicolon. -h --help Shows the help message -v --version Prints Samarium version There is also a VSCode syntax highlighting extension for Samarium, which can be found here here . Its source code can be found here .","title":"Using Samarium"},{"location":"#credits","text":"Samarium was inspired by several languages, including brainfuck , Rust , Python and Java . Special thanks to: tetraxile for helping with design choices and writing the docs MithicSpirit for making an AUR package for Samarium DarviL82 for fixing some issues Endercheif for making the documentation look fancy and helping with design choices If you have any questions, or would like to get in touch, join the Discord server !","title":"Credits"},{"location":"arrays/","text":"Arrays Arrays are defined using square brackets, with items separated by commas: [\\, /\\, //] Arrays can be concatenated with the + operator: [/, /\\] + [//] is the same as [/, /\\, //] Items can also be removed from an array using the - operator, either by index or by value. Removing an element by value will remove only the first instance of that value in the array. [\"a\", \"b\", \"c\"] - / gives [\"a\", \"c\"] [\"a\", \"b\", \"c\", \"d\"] - [\"b\", \"d\"] gives [\"a\", \"c\"]","title":"Arrays"},{"location":"arrays/#arrays","text":"Arrays are defined using square brackets, with items separated by commas: [\\, /\\, //] Arrays can be concatenated with the + operator: [/, /\\] + [//] is the same as [/, /\\, //] Items can also be removed from an array using the - operator, either by index or by value. Removing an element by value will remove only the first instance of that value in the array. [\"a\", \"b\", \"c\"] - / gives [\"a\", \"c\"] [\"a\", \"b\", \"c\", \"d\"] - [\"b\", \"d\"] gives [\"a\", \"c\"]","title":"Arrays"},{"location":"builtins/","text":"Built-in Functions INPUT Standard input can be read from with ??? . It will read until it receives a newline character. x: ??? will assign to x as a string what it reads from standard input, stopping at a newline character. A prompt can be given by preceding the ??? with a string, for example \"input: \"??? . PRINTLN Objects can be written to standard output by appending a ! character to them. Note that they won't be written exactly as they would appear in Samarium. \"a\"! will write a to standard output. //\\/! will write 13 to standard output. This function will return what it writes to stdout (though not necessarily as a string), and can thus be used in an assignment statement for example. x: //\\!; == the string \"6\" is written to stdout, and `x` now has the value 6 (integer) THROW Similarly to PRINTLN, objects can be written to standard error using !!! . This will throw an error, and exit the program if the error is not caught. \"exception raised\"!!! will write [Error] exception raised to standard error. EXIT The program may be exited with =>! . If a particular exit code is desired, it may be put after the exclamation mark: =>! // will exit the program with exit code 3. HASH The hash function ## returns as a integer the hash value of an object if it has one (arrays and tables do not). The value it returns will remain consistent for the life of the program, but may vary if the program is run multiple times. \"hash\"## will return the hash value of the string \"hash\" . TYPEOF The typeof function ?! returns the type of an object, as an instance of the Type class. /?! returns Integer . \"abc\"?! returns String . /?!?! returns Type . These instances are callable and can be used to convert values into that type, like so: \\?!(\"123\") + /\\!; == writes `125` to stdout Related library: types CAST The cast function % can convert between a Unicode character (a string) and its corresponding code (an integer). \"a\"% returns 97 . /\\\\\\\\/% returns \"!\" . SPECIAL The special method $ has different uses depending on the type of object it's used on. Object Use Array Returns the length of the array Function Returns the number of parameters the function has Integer Returns the binary representation of the integer as a string Slice Returns the length of the range covered by the slice String Returns the length of the string Table Returns an array of the table's values For example: \"string\"$!; == writes `6` to stdout TIMESTAMP The timestamp function @@ returns the time in milliseconds since the epoch. Note Timezone is included. For UTC timestamp, use datetime.timestamp_utc . DTNOW The dtnow function @@@ gets the system's current date and time as an array of integers, in the format [year, month, day, hour, minute, second, millisecond, utc_hour_offset, utc_minute_offset] . SLEEP The sleep function ,., pauses execution for the specified number of milliseconds. ,., /////\\/\\\\\\; == sleep for 1000 milliseconds (1 second) ASSERT The assert function !! is used as a debugging tool. If the input to this function is falsy (i.e. empty iterable, null, or just false), an AssertionError will be raised, otherwise, nothing will happen. A custom error message can be provided by putting it after a , . !! / > /\\, \"error message\"; will raise [AssertionError] error message . PARENT The parent function !? gets the parent/inherited classes of the input class. If a class only has one parent, it will be return directly. If a class has multiple parents, they will be returned in an array, in the same order as in the class definition. Note that this will only go one layer deep, i.e. if class A has parent B and class B has parent C , A!? will only return B , and A!?!? will return C . RANDOM The special method ?? has different uses depending on the type of object it's used on. Object Use Array Returns a random element Integer Returns a random integer from an interval based on its value n = 0 \u2192 0 n > 0 \u2192 [0, n) n < 0 \u2192 [n, 0) Slice Returns a random number that fits the slice's conditions String Returns a random character Table Returns a random key Related library: random ID The special method ** returns the memory address of a given object. x: //; x**!; == 7f7ea0367800","title":"Built-in Functions"},{"location":"builtins/#built-in-functions","text":"","title":"Built-in Functions"},{"location":"builtins/#input","text":"Standard input can be read from with ??? . It will read until it receives a newline character. x: ??? will assign to x as a string what it reads from standard input, stopping at a newline character. A prompt can be given by preceding the ??? with a string, for example \"input: \"??? .","title":"INPUT"},{"location":"builtins/#println","text":"Objects can be written to standard output by appending a ! character to them. Note that they won't be written exactly as they would appear in Samarium. \"a\"! will write a to standard output. //\\/! will write 13 to standard output. This function will return what it writes to stdout (though not necessarily as a string), and can thus be used in an assignment statement for example. x: //\\!; == the string \"6\" is written to stdout, and `x` now has the value 6 (integer)","title":"PRINTLN"},{"location":"builtins/#throw","text":"Similarly to PRINTLN, objects can be written to standard error using !!! . This will throw an error, and exit the program if the error is not caught. \"exception raised\"!!! will write [Error] exception raised to standard error.","title":"THROW"},{"location":"builtins/#exit","text":"The program may be exited with =>! . If a particular exit code is desired, it may be put after the exclamation mark: =>! // will exit the program with exit code 3.","title":"EXIT"},{"location":"builtins/#hash","text":"The hash function ## returns as a integer the hash value of an object if it has one (arrays and tables do not). The value it returns will remain consistent for the life of the program, but may vary if the program is run multiple times. \"hash\"## will return the hash value of the string \"hash\" .","title":"HASH"},{"location":"builtins/#typeof","text":"The typeof function ?! returns the type of an object, as an instance of the Type class. /?! returns Integer . \"abc\"?! returns String . /?!?! returns Type . These instances are callable and can be used to convert values into that type, like so: \\?!(\"123\") + /\\!; == writes `125` to stdout Related library: types","title":"TYPEOF"},{"location":"builtins/#cast","text":"The cast function % can convert between a Unicode character (a string) and its corresponding code (an integer). \"a\"% returns 97 . /\\\\\\\\/% returns \"!\" .","title":"CAST"},{"location":"builtins/#special","text":"The special method $ has different uses depending on the type of object it's used on. Object Use Array Returns the length of the array Function Returns the number of parameters the function has Integer Returns the binary representation of the integer as a string Slice Returns the length of the range covered by the slice String Returns the length of the string Table Returns an array of the table's values For example: \"string\"$!; == writes `6` to stdout","title":"SPECIAL"},{"location":"builtins/#timestamp","text":"The timestamp function @@ returns the time in milliseconds since the epoch. Note Timezone is included. For UTC timestamp, use datetime.timestamp_utc .","title":"TIMESTAMP"},{"location":"builtins/#dtnow","text":"The dtnow function @@@ gets the system's current date and time as an array of integers, in the format [year, month, day, hour, minute, second, millisecond, utc_hour_offset, utc_minute_offset] .","title":"DTNOW"},{"location":"builtins/#sleep","text":"The sleep function ,., pauses execution for the specified number of milliseconds. ,., /////\\/\\\\\\; == sleep for 1000 milliseconds (1 second)","title":"SLEEP"},{"location":"builtins/#assert","text":"The assert function !! is used as a debugging tool. If the input to this function is falsy (i.e. empty iterable, null, or just false), an AssertionError will be raised, otherwise, nothing will happen. A custom error message can be provided by putting it after a , . !! / > /\\, \"error message\"; will raise [AssertionError] error message .","title":"ASSERT"},{"location":"builtins/#parent","text":"The parent function !? gets the parent/inherited classes of the input class. If a class only has one parent, it will be return directly. If a class has multiple parents, they will be returned in an array, in the same order as in the class definition. Note that this will only go one layer deep, i.e. if class A has parent B and class B has parent C , A!? will only return B , and A!?!? will return C .","title":"PARENT"},{"location":"builtins/#random","text":"The special method ?? has different uses depending on the type of object it's used on. Object Use Array Returns a random element Integer Returns a random integer from an interval based on its value n = 0 \u2192 0 n > 0 \u2192 [0, n) n < 0 \u2192 [n, 0) Slice Returns a random number that fits the slice's conditions String Returns a random character Table Returns a random key Related library: random","title":"RANDOM"},{"location":"builtins/#id","text":"The special method ** returns the memory address of a given object. x: //; x**!; == 7f7ea0367800","title":"ID"},{"location":"classes/","text":"Classes Classes are defined with the @ character. Any inherited classes can follow the name of the class in parentheses, separated by commas 1 . Class variables and methods are defined inside curly braces. Inside a class' methods, the ' character can be used to reference its instance variables and methods. Class variables are those that are shared between all instances of a class, and instance variables are for data unique to each instance. Class variables, instance variables and methods can be accessed with the . operator on an instance of the class. In this case, class methods will implicitly be given a reference to the instance as the first argument of the method; x.method(arg1, arg2, ...) is equivalent to x?!.method(x, arg1, arg2, ...) . Class variables and methods can also be accessed in the same way directly from the class itself, though note that in this case methods will not implicitly have an instance as the first argument, so it must be provided. Just like variables, class attributes can be made private by prefixing them with # , making them inaccessible outside the class. @ Foo { shared: []; create var * { 'var: var; '#pv: var - /; } get_pv * { * '#pv; } } => * { a: Foo(/\\\\); == calls `Foo.create`; `a` is now an instance of `Foo` a.var!; == prints 5 a.get_pv()!; == calls `Foo.get_pv(a)`; prints 4 b: Foo(/\\); a.shared+: [\"str\"]; == modifying a class variable for all instances b.shared!; == prints [\"str\"] } Parent classes are inherited from right to left, i.e. the first class in the inheritance takes priority and will overwrite any functions/variables defined by the following classes: @ A { method * { \"A\"!; } } @ B { method * { \"B\"!; } } @ C(A, B) {} => * { c: C(); c.method(); == prints \"A\", as class A was inherited last } There are a number of special methods that the user can implement to override certain functionality of a class, such as how it's initialized (with the create method), or how it interacts with different operators. These methods are as follows (where func(...) indicates a variable number of arguments): Function Python Use add(other) add Interacts with the addition operator + . add_assign(other) iadd Interacts with the addition assignment operator +: . x+: y is equivalent to x.add_assign(y) (or x: x + y ). and(other) and Interacts with the bitwise AND operator & . and_assign(other) iand Interacts with the bitwise AND assignment operator &: . call(...) call Called when an instance itself is \"called\" as a function; x(...) roughly translates to x?!.call(x, ...) . cast() -- Interacts with the cast function character % . create(...) init Initializes an instance of a class, takes any number of arguments. Typically used for setting instance variables based on these arguments. No return value necessary. divide(other) floordiv Interacts with the division operator -- . divide_assign(other) ifloordiv Interacts with the division assignment operator --: . equals(other) eq Implements the equality operator :: . get_item(index) getitem Implements indexing an object; x<<index>> is equivalent to x.get_item(index) . greater_than(other) gt Implements the greater than operator > . greater_than_or_equal(other) ge Implements the greater than or equal operator >: . has(item) contains Implements membership testing, returns 1 (object contains item ) or 0 (object does not contain item ). Interacts with ->? operator. hash() hash Called by the built-in hash function ## , and for keys in a table. Objects which compare equal should have the same hash value. iterate() iter Called when iterating over an object in a foreach loop. Returns an array of objects to iterate over. less_than(other) lt Implements the less than operator < . less_than_or_equal(other) le Implements the less than or equal operator <: . mod(other) mod Interacts with the modulo operator --- . mod_assign(other) imod Interacts with the modulo assignment operator ---: . multiply(other) mul Interacts with the multiplication operator ++ . multiply_assign(other) imul Interacts with the multiplication assignment operator ++: . negative() neg Interacts with the negative unary operator - . not() invert Interacts with the bitwise NOT operator ~ . not_equals(other) ne Implements the inequality operator ::: . or(other) or Interacts with the bitwise OR operator \\| . or_assign(other) ior Interacts with the bitwise OR assignment operator \\|: . positive() pos Interacts with the positive unary operator + . power(other) pow Interacts with the exponentiation operator +++ . power_assign(other) ipow Interacts with the exponentiation assignment operator +++: . set_item(index, value) setitem Implements assigning to an index of an object; x<<index>>: value is equivalent to x.set_item(index, value) . special() -- Interacts with the special function character $ . subtract(other) sub Interacts with the subtraction operator - . subtract_assign(other) isub Interacts with the subtraction assignment operator -: . to_bit() bool Implements boolean value testing, returns 1 (truthy) or 0 (falsy). Used for conditional statements and logical operators. to_string() str Returns the string representation of an object. xor(other) xor Interacts with the bitwise XOR operator ^ . xor_assign(other) ixor Interacts with the bitwise XOR assignment operator ^: . Two special methods \u2013 create and to_string \u2013 have default definitions: @ Foo {} => * { f: Foo(); f!; == <Foo@7fe5403d7b00> } The above class definition is equivalent to: @ Foo { create * {} to_string * { <-string.format; * format(\"<$name@$address>\", {{\"name\" -> '?!, \"address\" -> '**}}); } } Some of the comparison operators can be inferred from others, so not all of them are necessary to provide implementations for. The specific operators needed to infer each comparison operator are listed in the following table: Operator Inferred from ::: :: < > and :: <: > >: > and :: Classes As Entry Points A class named => can serve as an entry point instead of a function: => argv * { \"Hello, \" + argv<</>>!; } @ => { create argv * { \"Hello, \" + argv<</>>!; } } Class Decorators Decorators can also be created using classes: @ OutputStorage { create func * { 'func: func; 'outputs: []; } call args... * { out: 'function(**args); 'outputs_: [out]; * out; } } OutputStorage @ multiply a b * { * a ++ b; } multiply(/\\, /\\/)!; == 10 multiply(//, ///)!; == 21 multiply(/\\\\/, //\\\\)!; == 108 multiply.outputs!; == [10, 21, 108] Note that order will be preserved here \u2014 if both class A and class B implement a function f , and class C inherits them in the order (A, B) , then C will inherit f from class A , as it is inherited later. \u21a9","title":"Classes"},{"location":"classes/#classes","text":"Classes are defined with the @ character. Any inherited classes can follow the name of the class in parentheses, separated by commas 1 . Class variables and methods are defined inside curly braces. Inside a class' methods, the ' character can be used to reference its instance variables and methods. Class variables are those that are shared between all instances of a class, and instance variables are for data unique to each instance. Class variables, instance variables and methods can be accessed with the . operator on an instance of the class. In this case, class methods will implicitly be given a reference to the instance as the first argument of the method; x.method(arg1, arg2, ...) is equivalent to x?!.method(x, arg1, arg2, ...) . Class variables and methods can also be accessed in the same way directly from the class itself, though note that in this case methods will not implicitly have an instance as the first argument, so it must be provided. Just like variables, class attributes can be made private by prefixing them with # , making them inaccessible outside the class. @ Foo { shared: []; create var * { 'var: var; '#pv: var - /; } get_pv * { * '#pv; } } => * { a: Foo(/\\\\); == calls `Foo.create`; `a` is now an instance of `Foo` a.var!; == prints 5 a.get_pv()!; == calls `Foo.get_pv(a)`; prints 4 b: Foo(/\\); a.shared+: [\"str\"]; == modifying a class variable for all instances b.shared!; == prints [\"str\"] } Parent classes are inherited from right to left, i.e. the first class in the inheritance takes priority and will overwrite any functions/variables defined by the following classes: @ A { method * { \"A\"!; } } @ B { method * { \"B\"!; } } @ C(A, B) {} => * { c: C(); c.method(); == prints \"A\", as class A was inherited last } There are a number of special methods that the user can implement to override certain functionality of a class, such as how it's initialized (with the create method), or how it interacts with different operators. These methods are as follows (where func(...) indicates a variable number of arguments): Function Python Use add(other) add Interacts with the addition operator + . add_assign(other) iadd Interacts with the addition assignment operator +: . x+: y is equivalent to x.add_assign(y) (or x: x + y ). and(other) and Interacts with the bitwise AND operator & . and_assign(other) iand Interacts with the bitwise AND assignment operator &: . call(...) call Called when an instance itself is \"called\" as a function; x(...) roughly translates to x?!.call(x, ...) . cast() -- Interacts with the cast function character % . create(...) init Initializes an instance of a class, takes any number of arguments. Typically used for setting instance variables based on these arguments. No return value necessary. divide(other) floordiv Interacts with the division operator -- . divide_assign(other) ifloordiv Interacts with the division assignment operator --: . equals(other) eq Implements the equality operator :: . get_item(index) getitem Implements indexing an object; x<<index>> is equivalent to x.get_item(index) . greater_than(other) gt Implements the greater than operator > . greater_than_or_equal(other) ge Implements the greater than or equal operator >: . has(item) contains Implements membership testing, returns 1 (object contains item ) or 0 (object does not contain item ). Interacts with ->? operator. hash() hash Called by the built-in hash function ## , and for keys in a table. Objects which compare equal should have the same hash value. iterate() iter Called when iterating over an object in a foreach loop. Returns an array of objects to iterate over. less_than(other) lt Implements the less than operator < . less_than_or_equal(other) le Implements the less than or equal operator <: . mod(other) mod Interacts with the modulo operator --- . mod_assign(other) imod Interacts with the modulo assignment operator ---: . multiply(other) mul Interacts with the multiplication operator ++ . multiply_assign(other) imul Interacts with the multiplication assignment operator ++: . negative() neg Interacts with the negative unary operator - . not() invert Interacts with the bitwise NOT operator ~ . not_equals(other) ne Implements the inequality operator ::: . or(other) or Interacts with the bitwise OR operator \\| . or_assign(other) ior Interacts with the bitwise OR assignment operator \\|: . positive() pos Interacts with the positive unary operator + . power(other) pow Interacts with the exponentiation operator +++ . power_assign(other) ipow Interacts with the exponentiation assignment operator +++: . set_item(index, value) setitem Implements assigning to an index of an object; x<<index>>: value is equivalent to x.set_item(index, value) . special() -- Interacts with the special function character $ . subtract(other) sub Interacts with the subtraction operator - . subtract_assign(other) isub Interacts with the subtraction assignment operator -: . to_bit() bool Implements boolean value testing, returns 1 (truthy) or 0 (falsy). Used for conditional statements and logical operators. to_string() str Returns the string representation of an object. xor(other) xor Interacts with the bitwise XOR operator ^ . xor_assign(other) ixor Interacts with the bitwise XOR assignment operator ^: . Two special methods \u2013 create and to_string \u2013 have default definitions: @ Foo {} => * { f: Foo(); f!; == <Foo@7fe5403d7b00> } The above class definition is equivalent to: @ Foo { create * {} to_string * { <-string.format; * format(\"<$name@$address>\", {{\"name\" -> '?!, \"address\" -> '**}}); } } Some of the comparison operators can be inferred from others, so not all of them are necessary to provide implementations for. The specific operators needed to infer each comparison operator are listed in the following table: Operator Inferred from ::: :: < > and :: <: > >: > and ::","title":"Classes"},{"location":"classes/#classes-as-entry-points","text":"A class named => can serve as an entry point instead of a function: => argv * { \"Hello, \" + argv<</>>!; } @ => { create argv * { \"Hello, \" + argv<</>>!; } }","title":"Classes As Entry Points"},{"location":"classes/#class-decorators","text":"Decorators can also be created using classes: @ OutputStorage { create func * { 'func: func; 'outputs: []; } call args... * { out: 'function(**args); 'outputs_: [out]; * out; } } OutputStorage @ multiply a b * { * a ++ b; } multiply(/\\, /\\/)!; == 10 multiply(//, ///)!; == 21 multiply(/\\\\/, //\\\\)!; == 108 multiply.outputs!; == [10, 21, 108] Note that order will be preserved here \u2014 if both class A and class B implement a function f , and class C inherits them in the order (A, B) , then C will inherit f from class A , as it is inherited later. \u21a9","title":"Class Decorators"},{"location":"comments/","text":"Comments Comments are written using == , and comment blocks are written with ==< and >== : == single-line comment ==< comment block doesn't end on newlines >==","title":"Comments"},{"location":"comments/#comments","text":"Comments are written using == , and comment blocks are written with ==< and >== : == single-line comment ==< comment block doesn't end on newlines >==","title":"Comments"},{"location":"controlflow/","text":"Control Flow if / else if statements are written using a ? character, and else is written as ,, . Blocks are enclosed in curly brackets. else if can be written using ,, ? . ? x < \\ { \"x is negative\"!; } ,, ? x > \\ { \"x is positive\"!; } ,, { \"x = 0\"!; } foreach loop foreach loops are written using ... , and enclosed in curly brackets. Each of these loops must be paired with a ->? operator, indicating the object to iterate over. arr: []; ... char ->? \"string\" { arr+: [char]; } == arr :: [\"s\", \"t\", \"r\", \"i\", \"n\", \"g\"] Comprehensions Array Comprehensions Array comprehensions are a way to create an array based on another iterable. Uses may include performing an operation on each item of the iterable, or creating a subsequence of those items that satisfy a certain condition. They are written similarly to foreach loops; they can come in two forms, as follows: [expression ... member ->? iterable] [expression ... member ->? iterable ? condition] For example, say we want to create an array of square numbers. Here are two equivalent approaches: input: [/, /\\, //, /\\\\, /\\/]; arr: []; ... n ->? input { arr+: [n ++ n]; } arr: [n ++ n ... n ->? input]; In both cases, arr is equal to [1, 4, 9, 16, 25] . Now suppose we want to filter this result to only the odd-numbered items. There are again two equivalent approaches: arr: [/, /\\\\, /\\\\/, /\\\\\\\\, //\\\\/]; filtered: []; ... n ->? arr { ? n --- /\\ :: / { filtered+: [n]; } } filtered: [n ... n ->? arr ? n --- /\\ :: /]; In both cases, filtered is equal to [1, 9, 25] . Table Comprehensions Table comprehensions have a similar syntax to array comprehensions: {{key -> value ... member ->? iterable}} {{key -> value ... member ->? iterable ? condition}} For example, both of the following approaches are equivalent: tab: {{}}; ... x ->? [/\\, /\\\\, //\\] { tab<<x>>: x ++ x; } tab: {{x -> x ++ x ... x ->? [/\\, /\\\\, //\\]}}; In both cases, tab is equal to {{2 -> 4, 4 -> 16, 6 -> 36}} . while loop while loops are written with .. , and enclosed in curly brackets. The loop condition follows the .. . An infinite loop is created when no condition is given. x: \\; .. x < /\\/\\ { x+: /\\; x!; } == prints 2, 4, 6, 8, 10 break / continue break statements are written with <- , and terminate the enclosing loop immediately. They can be used in both for and while loops. x: \\; .. x < /\\/ { x+: /; ? x :: // { <- } x!; } This program will print 1, 2, and then terminate the while loop on the third iteration, before printing 3. continue statements are written with -> , and immediately finish the current iteration of the enclosing loop. These can also be used in both for and while loops. x: \\; .. x < /\\/ { x+: /; ? x :: // { -> } x!; } This program will print 1, 2, skip the third iteration of the while loop, then print 4, 5, and end the loop normally. Note Both <- and -> do not need a semicolon at the end of the statement \u2013 it's optional. try / catch try - catch statements are used for error handling. try clauses are written with ?? , and enclosed in curly brackets. If, during execution of the contents of the try clause, an error is thrown, the rest of the clause is skipped, the error will be silenced, and the adjoining catch clause will be executed. catch clauses are written with !! , and are also enclosed in curly brackets. ?? { == error prone code here... / -- \\; \"unreachable\"!; } !! { \"error caught\"!; }","title":"Control Flow"},{"location":"controlflow/#control-flow","text":"","title":"Control Flow"},{"location":"controlflow/#ifelse","text":"if statements are written using a ? character, and else is written as ,, . Blocks are enclosed in curly brackets. else if can be written using ,, ? . ? x < \\ { \"x is negative\"!; } ,, ? x > \\ { \"x is positive\"!; } ,, { \"x = 0\"!; }","title":"if/else"},{"location":"controlflow/#foreach-loop","text":"foreach loops are written using ... , and enclosed in curly brackets. Each of these loops must be paired with a ->? operator, indicating the object to iterate over. arr: []; ... char ->? \"string\" { arr+: [char]; } == arr :: [\"s\", \"t\", \"r\", \"i\", \"n\", \"g\"]","title":"foreach loop"},{"location":"controlflow/#comprehensions","text":"","title":"Comprehensions"},{"location":"controlflow/#array-comprehensions","text":"Array comprehensions are a way to create an array based on another iterable. Uses may include performing an operation on each item of the iterable, or creating a subsequence of those items that satisfy a certain condition. They are written similarly to foreach loops; they can come in two forms, as follows: [expression ... member ->? iterable] [expression ... member ->? iterable ? condition] For example, say we want to create an array of square numbers. Here are two equivalent approaches: input: [/, /\\, //, /\\\\, /\\/]; arr: []; ... n ->? input { arr+: [n ++ n]; } arr: [n ++ n ... n ->? input]; In both cases, arr is equal to [1, 4, 9, 16, 25] . Now suppose we want to filter this result to only the odd-numbered items. There are again two equivalent approaches: arr: [/, /\\\\, /\\\\/, /\\\\\\\\, //\\\\/]; filtered: []; ... n ->? arr { ? n --- /\\ :: / { filtered+: [n]; } } filtered: [n ... n ->? arr ? n --- /\\ :: /]; In both cases, filtered is equal to [1, 9, 25] .","title":"Array Comprehensions"},{"location":"controlflow/#table-comprehensions","text":"Table comprehensions have a similar syntax to array comprehensions: {{key -> value ... member ->? iterable}} {{key -> value ... member ->? iterable ? condition}} For example, both of the following approaches are equivalent: tab: {{}}; ... x ->? [/\\, /\\\\, //\\] { tab<<x>>: x ++ x; } tab: {{x -> x ++ x ... x ->? [/\\, /\\\\, //\\]}}; In both cases, tab is equal to {{2 -> 4, 4 -> 16, 6 -> 36}} .","title":"Table Comprehensions"},{"location":"controlflow/#while-loop","text":"while loops are written with .. , and enclosed in curly brackets. The loop condition follows the .. . An infinite loop is created when no condition is given. x: \\; .. x < /\\/\\ { x+: /\\; x!; } == prints 2, 4, 6, 8, 10","title":"while loop"},{"location":"controlflow/#breakcontinue","text":"break statements are written with <- , and terminate the enclosing loop immediately. They can be used in both for and while loops. x: \\; .. x < /\\/ { x+: /; ? x :: // { <- } x!; } This program will print 1, 2, and then terminate the while loop on the third iteration, before printing 3. continue statements are written with -> , and immediately finish the current iteration of the enclosing loop. These can also be used in both for and while loops. x: \\; .. x < /\\/ { x+: /; ? x :: // { -> } x!; } This program will print 1, 2, skip the third iteration of the while loop, then print 4, 5, and end the loop normally. Note Both <- and -> do not need a semicolon at the end of the statement \u2013 it's optional.","title":"break/continue"},{"location":"controlflow/#trycatch","text":"try - catch statements are used for error handling. try clauses are written with ?? , and enclosed in curly brackets. If, during execution of the contents of the try clause, an error is thrown, the rest of the clause is skipped, the error will be silenced, and the adjoining catch clause will be executed. catch clauses are written with !! , and are also enclosed in curly brackets. ?? { == error prone code here... / -- \\; \"unreachable\"!; } !! { \"error caught\"!; }","title":"try/catch"},{"location":"enums/","text":"Enums Enums are defined using the # character, before which comes the name of the enum. Each of the enum members has to be separated with a semicolon. By default, enum members are assigned increasing numbers, starting from 0. You can provide your own values for enum members by simply assigning values to the names. Enum members cannot be modified. Shape # { Circle; Square; } Color # { Red: \"#FF0000\"; Green: \"#00FF00\"; Blue: \"#0000FF\"; } => * { Shape!; Shape.Circle!; Shape.Square!; Color.Red!; } Enum(Shape) 0 1 #FF0000","title":"Enums"},{"location":"enums/#enums","text":"Enums are defined using the # character, before which comes the name of the enum. Each of the enum members has to be separated with a semicolon. By default, enum members are assigned increasing numbers, starting from 0. You can provide your own values for enum members by simply assigning values to the names. Enum members cannot be modified. Shape # { Circle; Square; } Color # { Red: \"#FF0000\"; Green: \"#00FF00\"; Blue: \"#0000FF\"; } => * { Shape!; Shape.Circle!; Shape.Square!; Color.Red!; } Enum(Shape) 0 1 #FF0000","title":"Enums"},{"location":"examples/","text":"Examples Reverse a file's contents => argv * { file: argv<</>>; data <~ file; data<<....-/>> ~> file; } Truth Machine => * { ? ??? :: \"1\" { .. { \"1\"!; } } \"0\"!; =>!; } Dropsort dropsort array * { <-iter.enumerate; out: []; ... i, v ->? enumerate(array) { ? ~~ out || v >: out<<-/>> { out+: [v]; } } * out; } Factorial factorial n * { !! n >: \\; ? ~~ n { * /; } * n ++ factorial(n - /); } Variable Arguments point coords... * { <-string.join; <-types.String; * \"(\" + join(coords, \", \") + \") is a \" + String(coords$) + \"D point\"; } => * { point()!; == () is a 0D point point(\\)!; == (0) is a 1D point point(//, -/\\\\)!; == (3, -4) is a 2D point point(-/\\, /\\\\, -/\\/)!; == (-2, 4, -5) is a 3D point point(///, -///, -/\\/, -/)!; == (7, -7, -5, -1) is a 4D point } Loop Flow => * { <-iter.range; nums: range(/, /\\//)!; ... n ->? nums { ? n --- /\\ :: \\ { -> } ? n :: /\\\\/ { <- } n!; } } ==< [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 1 3 5 7 >== Randomness random_hex_color * { <-iter.range; <-string.hexdigits, join; * \"#\" + join([hexdigits?? ... i ->? range(/\\\\)]); } == could alternatively define that as random_hex_color * { max: /\\ +++ //\\\\\\; <-string.leftpad; <-math.to_hex; * \"#\" + leftpad(to_hex(max??), //\\, \"0\"); } => * { random_hex_color()!; == #d2300a random_hex_color()!; == #f866ce random_hex_color()!; == #8fb3cf } Optional Arguments roll_dice q? * { roll1 * { * //\\?? + /; } q <> /; ? q :: / { * roll1(); } ,, { <-iter.range; * [roll1() ... i ->? range(q)]; } } => * { roll_dice()!; == 5 roll_dice(/\\)!; == [6, 3] roll_dice(/\\\\/\\/)!; == [5, 5, 6, 4, 6, 5, 6, 4, 5, 4, 4, 6, 5, 3, 6, 6, 2, 1, 4, 5, 5, 1, 2, 1] } Classes @ Rectangle { create a b * { 'a: a; 'b: b; } to_string * { <-types.String; * \"Rectangle[\" + String('a) + \", \" + String('b) + \"]\"; } circumference * { * 'a ++ /\\ + 'b ++ /\\; } area * { * 'a ++ 'b; } is_square * { * 'a :: 'b; } } => * { r: Rectangle(/\\\\, //); r!; == Rectangle[4, 3] r.circumference()!; == 14 r.area()!; == 12 r.is_square()!; == 0 } Decorators log_call func * { wrapper args... * { \"Calling function\", func, \"with args\", args!; * func(**args); } * wrapper; } log_call @ pow a b * { * a +++ b; } => * { pow(/\\, //)!; == Calling function pow with args [2, 3] == 8 }","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#reverse-a-files-contents","text":"=> argv * { file: argv<</>>; data <~ file; data<<....-/>> ~> file; }","title":"Reverse a file's contents"},{"location":"examples/#truth-machine","text":"=> * { ? ??? :: \"1\" { .. { \"1\"!; } } \"0\"!; =>!; }","title":"Truth Machine"},{"location":"examples/#dropsort","text":"dropsort array * { <-iter.enumerate; out: []; ... i, v ->? enumerate(array) { ? ~~ out || v >: out<<-/>> { out+: [v]; } } * out; }","title":"Dropsort"},{"location":"examples/#factorial","text":"factorial n * { !! n >: \\; ? ~~ n { * /; } * n ++ factorial(n - /); }","title":"Factorial"},{"location":"examples/#variable-arguments","text":"point coords... * { <-string.join; <-types.String; * \"(\" + join(coords, \", \") + \") is a \" + String(coords$) + \"D point\"; } => * { point()!; == () is a 0D point point(\\)!; == (0) is a 1D point point(//, -/\\\\)!; == (3, -4) is a 2D point point(-/\\, /\\\\, -/\\/)!; == (-2, 4, -5) is a 3D point point(///, -///, -/\\/, -/)!; == (7, -7, -5, -1) is a 4D point }","title":"Variable Arguments"},{"location":"examples/#loop-flow","text":"=> * { <-iter.range; nums: range(/, /\\//)!; ... n ->? nums { ? n --- /\\ :: \\ { -> } ? n :: /\\\\/ { <- } n!; } } ==< [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 1 3 5 7 >==","title":"Loop Flow"},{"location":"examples/#randomness","text":"random_hex_color * { <-iter.range; <-string.hexdigits, join; * \"#\" + join([hexdigits?? ... i ->? range(/\\\\)]); } == could alternatively define that as random_hex_color * { max: /\\ +++ //\\\\\\; <-string.leftpad; <-math.to_hex; * \"#\" + leftpad(to_hex(max??), //\\, \"0\"); } => * { random_hex_color()!; == #d2300a random_hex_color()!; == #f866ce random_hex_color()!; == #8fb3cf }","title":"Randomness"},{"location":"examples/#optional-arguments","text":"roll_dice q? * { roll1 * { * //\\?? + /; } q <> /; ? q :: / { * roll1(); } ,, { <-iter.range; * [roll1() ... i ->? range(q)]; } } => * { roll_dice()!; == 5 roll_dice(/\\)!; == [6, 3] roll_dice(/\\\\/\\/)!; == [5, 5, 6, 4, 6, 5, 6, 4, 5, 4, 4, 6, 5, 3, 6, 6, 2, 1, 4, 5, 5, 1, 2, 1] }","title":"Optional Arguments"},{"location":"examples/#classes","text":"@ Rectangle { create a b * { 'a: a; 'b: b; } to_string * { <-types.String; * \"Rectangle[\" + String('a) + \", \" + String('b) + \"]\"; } circumference * { * 'a ++ /\\ + 'b ++ /\\; } area * { * 'a ++ 'b; } is_square * { * 'a :: 'b; } } => * { r: Rectangle(/\\\\, //); r!; == Rectangle[4, 3] r.circumference()!; == 14 r.area()!; == 12 r.is_square()!; == 0 }","title":"Classes"},{"location":"examples/#decorators","text":"log_call func * { wrapper args... * { \"Calling function\", func, \"with args\", args!; * func(**args); } * wrapper; } log_call @ pow a b * { * a +++ b; } => * { pow(/\\, //)!; == Calling function pow with args [2, 3] == 8 }","title":"Decorators"},{"location":"fileio/","text":"File I/O Files are handled through file I/O objects, which can be in one of several modes: read, write, read & write, append, and as either text or binary for each of these. File I/O objects have a cursor, which is updated whenever data is written to/read from the object. The current cursor position can be gotten like so: pos: f<<>>; == assuming `f` is a file I/O object Creating Files can be created with the unary ?~> operator. ?~> \"file.txt\" will create an empty file called file.txt in the program directory. Note Files will also be created if they are opened in write or append mode. Reading Files can be opened for reading in two ways: f <~~ \"file.txt\"; == opens `file.txt` for reading, in text mode, == and stores the file I/O object in `f`. f <~% \"file.bin\"; == opens `file.bin` for reading, in binary mode, == and stores the file I/O object in `f`. These file I/O objects can be read into a variable (a string for text mode, and an array of integers for binary mode) for use in the program. string <~ f; == reads the full contents of the file I/O object `f` == into `string` (assuming `f` is in text read mode) array <% f; == reads the full contents of the file I/O object `f` == into `array` (assuming `f` is in binary read mode) Writing Files can be opened for writing in two ways: f ~~> \"file.txt\"; == opens/creates `file.txt` for writing, in text == mode, and stores the file I/O object in `f`. f %~> \"file.bin\"; == opens/creates `file.bin` for writing, in binary == mode, and stores the file I/O object in `f`. These file I/O objects can be written to from a variable (a string for text mode, and an array of integers for binary mode). string ~> f; == writes the entirety of `string` into the file I/O == object `f` (assuming `f` is in text write mode) string %> f; == writes the entire contents of `array` into the file I/O == object `f` (assuming `f` is in binary write mode) Appending Files can be opened for appending in two ways: f &~~> \"file.txt\"; == opens/creates `file.txt` for appending, in text == mode, and stores the file I/O object in `f`. f &%~> \"file.bin\"; == opens/creates `file.bin` for appending, in binary == mode, and stores the file I/O object in `f`. The contents of these file I/O objects can be added to from a variable (a string for text mode, and an array of integers for binary mode). string &~> f; == appends the entirety of `string` to the current contents of == the file I/O object `f` (assuming `f` is in text append mode) array &%> f; == appends the entirety of `array` to the current contents of == the file I/O object `f` (assuming `f` is in binary append mode) Closing Files can be closed with the ~ operator. If files are not closed manually by the user, they will be automatically closed once the program terminates. Note that the file I/O object will not be released from memory, but it still cannot be used. ~f; == closes the file I/O object `f` Quick Operations Files can be read from, written to or appended to directly using the filename, with quick operations. These will open the file in the relevant mode, perform the operation, and close it, all in one. Mode Operator Text read <~ Text write ~> Text append &~> Binary read <% Binary write %> Binary append &%> For example: string ~> \"file.txt\"; == writes the entirety of `string` directly into `file.txt` array <% \"file.bin\"; == reads the full contents of `file.bin` directly into `array` File Descriptors You can also use file descriptors instead of file paths in order to access standard I/O streams. Integer value Name \\ Standard Input / Standard Output /\\ Standard Error An example use of these could be printing without a newline at the end: => * { <-iter.range; ... i ->? range(/\\/\\) { i ~> /; } } The above code is equivalent to the following Python snippets: def main (): for i in range ( 10 ): print ( i , end = \"\" , flush = True ) if __name__ == \"__main__\" : main () import sys def main (): for i in range ( 10 ): sys . stdout . write ( str ( i )) sys . stdout . flush () if __name__ == \"__main__\" : main () All snippets produce the following output: 0123456789","title":"File I/O"},{"location":"fileio/#file-io","text":"Files are handled through file I/O objects, which can be in one of several modes: read, write, read & write, append, and as either text or binary for each of these. File I/O objects have a cursor, which is updated whenever data is written to/read from the object. The current cursor position can be gotten like so: pos: f<<>>; == assuming `f` is a file I/O object","title":"File I/O"},{"location":"fileio/#creating","text":"Files can be created with the unary ?~> operator. ?~> \"file.txt\" will create an empty file called file.txt in the program directory. Note Files will also be created if they are opened in write or append mode.","title":"Creating"},{"location":"fileio/#reading","text":"Files can be opened for reading in two ways: f <~~ \"file.txt\"; == opens `file.txt` for reading, in text mode, == and stores the file I/O object in `f`. f <~% \"file.bin\"; == opens `file.bin` for reading, in binary mode, == and stores the file I/O object in `f`. These file I/O objects can be read into a variable (a string for text mode, and an array of integers for binary mode) for use in the program. string <~ f; == reads the full contents of the file I/O object `f` == into `string` (assuming `f` is in text read mode) array <% f; == reads the full contents of the file I/O object `f` == into `array` (assuming `f` is in binary read mode)","title":"Reading"},{"location":"fileio/#writing","text":"Files can be opened for writing in two ways: f ~~> \"file.txt\"; == opens/creates `file.txt` for writing, in text == mode, and stores the file I/O object in `f`. f %~> \"file.bin\"; == opens/creates `file.bin` for writing, in binary == mode, and stores the file I/O object in `f`. These file I/O objects can be written to from a variable (a string for text mode, and an array of integers for binary mode). string ~> f; == writes the entirety of `string` into the file I/O == object `f` (assuming `f` is in text write mode) string %> f; == writes the entire contents of `array` into the file I/O == object `f` (assuming `f` is in binary write mode)","title":"Writing"},{"location":"fileio/#appending","text":"Files can be opened for appending in two ways: f &~~> \"file.txt\"; == opens/creates `file.txt` for appending, in text == mode, and stores the file I/O object in `f`. f &%~> \"file.bin\"; == opens/creates `file.bin` for appending, in binary == mode, and stores the file I/O object in `f`. The contents of these file I/O objects can be added to from a variable (a string for text mode, and an array of integers for binary mode). string &~> f; == appends the entirety of `string` to the current contents of == the file I/O object `f` (assuming `f` is in text append mode) array &%> f; == appends the entirety of `array` to the current contents of == the file I/O object `f` (assuming `f` is in binary append mode)","title":"Appending"},{"location":"fileio/#closing","text":"Files can be closed with the ~ operator. If files are not closed manually by the user, they will be automatically closed once the program terminates. Note that the file I/O object will not be released from memory, but it still cannot be used. ~f; == closes the file I/O object `f`","title":"Closing"},{"location":"fileio/#quick-operations","text":"Files can be read from, written to or appended to directly using the filename, with quick operations. These will open the file in the relevant mode, perform the operation, and close it, all in one. Mode Operator Text read <~ Text write ~> Text append &~> Binary read <% Binary write %> Binary append &%> For example: string ~> \"file.txt\"; == writes the entirety of `string` directly into `file.txt` array <% \"file.bin\"; == reads the full contents of `file.bin` directly into `array`","title":"Quick Operations"},{"location":"fileio/#file-descriptors","text":"You can also use file descriptors instead of file paths in order to access standard I/O streams. Integer value Name \\ Standard Input / Standard Output /\\ Standard Error An example use of these could be printing without a newline at the end: => * { <-iter.range; ... i ->? range(/\\/\\) { i ~> /; } } The above code is equivalent to the following Python snippets: def main (): for i in range ( 10 ): print ( i , end = \"\" , flush = True ) if __name__ == \"__main__\" : main () import sys def main (): for i in range ( 10 ): sys . stdout . write ( str ( i )) sys . stdout . flush () if __name__ == \"__main__\" : main () All snippets produce the following output: 0123456789","title":"File Descriptors"},{"location":"functions/","text":"Functions Functions are defined using the * character. Both the function's name and its parameters come before this * character, in that order, separated by spaces. The function body is enclosed in curly brackets. The function's return value is preceded by a * character as well. (Functions may also have multiple return statements, or none at all.) add a b * { sum: a + b; * sum; } Calling a function is done as in C-like languages, with the function name, followed by its arguments in parentheses, separated by commas. a: /; b: /\\; c: add(a, b); Optional Parameters Parameters can be made optional by adding a ? character after the parameter's name. Optional parameters are required to have a default value defined in the function's body using the param <> default syntax. == string.leftpad leftpad string length char? * { char <> \" \"; * pad(string, length, char) + string; } leftpad(\"hello\", /\\/\\)!; == hello leftpad(\"hello\", /\\/\\, \"-\")!; == -----hello Varargs A function can accept a variable number of arguments by adding ... after the last parameter's name. Packed arguments will be passed into the function as an array. product nums... * { prod: /; ... n ->? nums { prod++: n; } * prod; } prod()!; == 1 prod(///)!; == 7 prod(///, /\\/\\/)!; == 147 prod(/\\/, /\\\\\\/\\, /\\, /\\\\/\\\\\\, ///)!; == 171360 Argument Unpacking Arguments can be spread into a function by using the ** unary operator: pow a b * { * a +++ b; } arguments = [/\\, //]; pow(**arguments)!; == equivalent to pow(/\\, //)!; Decorators Decorators are syntactic sugar for calling a function/class which argument is another callable. To use a function as a decorator, write the name, @ and then declare the function it is decorating. == Decorator double func * { wrapper args... * { * func(**args) ++ /\\; } * wrapper; } == Decorated functions double @ multiply a b * { * a ++ b; } double @ code_to_char code * { * code%; } multiply(/\\, /\\\\)!; == 16 code_to_char(/\\\\\\\\/)!; == !! Iterators Functions can yield values instead of returning them, thus making the function behave like an iterator. Values are yielded with the ** operator: <-math.is_prime; prime_generator * { x: /\\; .. { ? is_prime(x) { ** x; } x+: /; } } => * { pg: prime_generator(); pg!; \"Primes below 100:\"!; ... i ->? pg { ? i > /\\/\\ +++ /\\ { !; <- } \"\"?!(i) + \" \" ~> /; } } <Iterator@7fd890475860> Primes below 100: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 Iterators support special $ and cast % methods. Iterator% returns the length of the iterator if available, and null otherwise. Iterator$ yields the next value of the iterator.","title":"Functions"},{"location":"functions/#functions","text":"Functions are defined using the * character. Both the function's name and its parameters come before this * character, in that order, separated by spaces. The function body is enclosed in curly brackets. The function's return value is preceded by a * character as well. (Functions may also have multiple return statements, or none at all.) add a b * { sum: a + b; * sum; } Calling a function is done as in C-like languages, with the function name, followed by its arguments in parentheses, separated by commas. a: /; b: /\\; c: add(a, b);","title":"Functions"},{"location":"functions/#optional-parameters","text":"Parameters can be made optional by adding a ? character after the parameter's name. Optional parameters are required to have a default value defined in the function's body using the param <> default syntax. == string.leftpad leftpad string length char? * { char <> \" \"; * pad(string, length, char) + string; } leftpad(\"hello\", /\\/\\)!; == hello leftpad(\"hello\", /\\/\\, \"-\")!; == -----hello","title":"Optional Parameters"},{"location":"functions/#varargs","text":"A function can accept a variable number of arguments by adding ... after the last parameter's name. Packed arguments will be passed into the function as an array. product nums... * { prod: /; ... n ->? nums { prod++: n; } * prod; } prod()!; == 1 prod(///)!; == 7 prod(///, /\\/\\/)!; == 147 prod(/\\/, /\\\\\\/\\, /\\, /\\\\/\\\\\\, ///)!; == 171360","title":"Varargs"},{"location":"functions/#argument-unpacking","text":"Arguments can be spread into a function by using the ** unary operator: pow a b * { * a +++ b; } arguments = [/\\, //]; pow(**arguments)!; == equivalent to pow(/\\, //)!;","title":"Argument Unpacking"},{"location":"functions/#decorators","text":"Decorators are syntactic sugar for calling a function/class which argument is another callable. To use a function as a decorator, write the name, @ and then declare the function it is decorating. == Decorator double func * { wrapper args... * { * func(**args) ++ /\\; } * wrapper; } == Decorated functions double @ multiply a b * { * a ++ b; } double @ code_to_char code * { * code%; } multiply(/\\, /\\\\)!; == 16 code_to_char(/\\\\\\\\/)!; == !!","title":"Decorators"},{"location":"functions/#iterators","text":"Functions can yield values instead of returning them, thus making the function behave like an iterator. Values are yielded with the ** operator: <-math.is_prime; prime_generator * { x: /\\; .. { ? is_prime(x) { ** x; } x+: /; } } => * { pg: prime_generator(); pg!; \"Primes below 100:\"!; ... i ->? pg { ? i > /\\/\\ +++ /\\ { !; <- } \"\"?!(i) + \" \" ~> /; } } <Iterator@7fd890475860> Primes below 100: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 Iterators support special $ and cast % methods. Iterator% returns the length of the iterator if available, and null otherwise. Iterator$ yields the next value of the iterator.","title":"Iterators"},{"location":"integers/","text":"Note The following guide assumes that you are familiar with the basics of programming. Integers Integers are represented in base 2, using slashes and backslashes to represent 1 and 0 respectively. Integers are the only type of number supported in Samarium. Negative integers are represented as normal, with a - sign before them. Let's see some examples of integers: Base 10 Base 2 Samarium 0 0 \\ 1 1 / 2 10 /\\ 3 11 // 5 101 /\\/ 8 1000 /\\\\\\ 13 1101 //\\/ 21 10101 /\\/\\/ Since Samarium is transpiled to Python, there's no limit to how large an integer can be: //\\\\/\\\\//////\\\\\\\\///\\\\////\\\\/\\\\/\\\\\\\\\\\\/////\\\\\\\\\\\\\\\\/////\\\\//\\\\/\\\\////\\\\////////\\\\////\\\\///\\\\\\\\\\\\\\\\//\\\\\\\\//\\\\///\\\\/\\\\\\\\\\\\/\\\\////\\\\//\\\\\\\\/\\\\\\\\/\\\\////\\\\/////\\\\/\\\\\\\\/\\\\\\\\\\\\\\\\\\\\//\\\\\\\\\\\\//\\\\\\\\/\\\\/\\\\\\\\//\\\\\\\\\\\\///\\\\/\\\\\\\\\\\\/\\\\\\\\\\\\/\\\\\\\\///\\\\//\\\\\\\\/\\\\\\\\//\\\\\\\\///\\\\//\\\\\\\\\\\\\\\\\\\\\\\\//////////////////////////////////////////////////////////////////////////////// Or in base 10: 99999999999999999999999999999999999999999999999999999999999999999999999999999999","title":"Integers"},{"location":"integers/#integers","text":"Integers are represented in base 2, using slashes and backslashes to represent 1 and 0 respectively. Integers are the only type of number supported in Samarium. Negative integers are represented as normal, with a - sign before them. Let's see some examples of integers: Base 10 Base 2 Samarium 0 0 \\ 1 1 / 2 10 /\\ 3 11 // 5 101 /\\/ 8 1000 /\\\\\\ 13 1101 //\\/ 21 10101 /\\/\\/ Since Samarium is transpiled to Python, there's no limit to how large an integer can be: //\\\\/\\\\//////\\\\\\\\///\\\\////\\\\/\\\\/\\\\\\\\\\\\/////\\\\\\\\\\\\\\\\/////\\\\//\\\\/\\\\////\\\\////////\\\\////\\\\///\\\\\\\\\\\\\\\\//\\\\\\\\//\\\\///\\\\/\\\\\\\\\\\\/\\\\////\\\\//\\\\\\\\/\\\\\\\\/\\\\////\\\\/////\\\\/\\\\\\\\/\\\\\\\\\\\\\\\\\\\\//\\\\\\\\\\\\//\\\\\\\\/\\\\/\\\\\\\\//\\\\\\\\\\\\///\\\\/\\\\\\\\\\\\/\\\\\\\\\\\\/\\\\\\\\///\\\\//\\\\\\\\/\\\\\\\\//\\\\\\\\///\\\\//\\\\\\\\\\\\\\\\\\\\\\\\//////////////////////////////////////////////////////////////////////////////// Or in base 10: 99999999999999999999999999999999999999999999999999999999999999999999999999999999","title":"Integers"},{"location":"modules/","text":"Modules Modules can contain functions and variables that a user may wish to import. Modules are named after their filename (with .sm omitted). Like variables, module names must consist of only letters and numbers, and are case sensitive. Importing Modules can be imported using the <- operator, followed by the module's name. Objects (classes, functions, variables) from this module can then be accessed with the . operator. <-string; == imports the `string` module from Samarium's standard library string.to_upper(\"abc\")!; == prints \"ABC\" string.digits!; == prints \"0123456789\" Objects can also be directly imported from a module one by one, in which case they don't need to be preceded by the module name when using them: <-math.abs, sqrt; sqrt(/\\\\/)!; == prints 3 abs(-/\\)!; == prints 2 All objects in a module can be directly imported at once by using the wildcard character * . Importing everything in this way is typically advised against, as it may cause poorly readable code and/or name collisions. <-math.*; factorial(//)!; == prints 6","title":"Modules"},{"location":"modules/#modules","text":"Modules can contain functions and variables that a user may wish to import. Modules are named after their filename (with .sm omitted). Like variables, module names must consist of only letters and numbers, and are case sensitive.","title":"Modules"},{"location":"modules/#importing","text":"Modules can be imported using the <- operator, followed by the module's name. Objects (classes, functions, variables) from this module can then be accessed with the . operator. <-string; == imports the `string` module from Samarium's standard library string.to_upper(\"abc\")!; == prints \"ABC\" string.digits!; == prints \"0123456789\" Objects can also be directly imported from a module one by one, in which case they don't need to be preceded by the module name when using them: <-math.abs, sqrt; sqrt(/\\\\/)!; == prints 3 abs(-/\\)!; == prints 2 All objects in a module can be directly imported at once by using the wildcard character * . Importing everything in this way is typically advised against, as it may cause poorly readable code and/or name collisions. <-math.*; factorial(//)!; == prints 6","title":"Importing"},{"location":"null/","text":"Null The null value in Samarium is not represented by any symbol\u2014in fact, it's represented by the lack of it: x: /; y:; z: [-/, , /]; The above code sets x to 1 , y to null , and z to [-1, null, 1] . The following code prints 1 if y is equal to null and null is present in z , and 0 otherwise. y :: && ->? z!; One could alias null for clarity: null:; y :: null && null ->? z!; The null value is not inserted implicitly for method calls, therefore: V: .to_bit(); has to be written as null:; V: null.to_bit(); or \u2013 without introducing any variables \u2013 as V: (||).to_bit();","title":"Null"},{"location":"null/#null","text":"The null value in Samarium is not represented by any symbol\u2014in fact, it's represented by the lack of it: x: /; y:; z: [-/, , /]; The above code sets x to 1 , y to null , and z to [-1, null, 1] . The following code prints 1 if y is equal to null and null is present in z , and 0 otherwise. y :: && ->? z!; One could alias null for clarity: null:; y :: null && null ->? z!; The null value is not inserted implicitly for method calls, therefore: V: .to_bit(); has to be written as null:; V: null.to_bit(); or \u2013 without introducing any variables \u2013 as V: (||).to_bit();","title":"Null"},{"location":"operators/","text":"Operators Arithmetic Operator Meaning + Addition - Subtraction ++ Multiplication -- Integer division +++ Exponentiation --- Modulo Unary Operator Meaning + Positive - Negative Comparison Operator Meaning < Less than > Greater than <: Less than or equal to >: Greater than or equal to :: Equal to ::: Not equal to Logic and Membership Operator Meaning && Logical AND || Logical OR ~~ Logical NOT ->? x ->? y returns 1 if x is a member of y , and 0 if not Bitwise Operator Meaning & Bitwise AND | Bitwise OR ~ Bitwise NOT ^ Bitwise XOR Assignment All arithmetic and bitwise operators (except ~ ) can be used together with the assignment operator. For example: x: x - /\\/; x: x ++ //; x: x --- /\\\\; is equivalent to: x-: /\\/; x++: //; x---: /\\\\;","title":"Operators"},{"location":"operators/#operators","text":"","title":"Operators"},{"location":"operators/#arithmetic","text":"Operator Meaning + Addition - Subtraction ++ Multiplication -- Integer division +++ Exponentiation --- Modulo","title":"Arithmetic"},{"location":"operators/#unary","text":"Operator Meaning + Positive - Negative","title":"Unary"},{"location":"operators/#comparison","text":"Operator Meaning < Less than > Greater than <: Less than or equal to >: Greater than or equal to :: Equal to ::: Not equal to","title":"Comparison"},{"location":"operators/#logic-and-membership","text":"Operator Meaning && Logical AND || Logical OR ~~ Logical NOT ->? x ->? y returns 1 if x is a member of y , and 0 if not","title":"Logic and Membership"},{"location":"operators/#bitwise","text":"Operator Meaning & Bitwise AND | Bitwise OR ~ Bitwise NOT ^ Bitwise XOR","title":"Bitwise"},{"location":"operators/#assignment","text":"All arithmetic and bitwise operators (except ~ ) can be used together with the assignment operator. For example: x: x - /\\/; x: x ++ //; x: x --- /\\\\; is equivalent to: x-: /\\/; x++: //; x---: /\\\\;","title":"Assignment"},{"location":"slices/","text":"Slices Slices are used to access a range of items in an iterable (strings, arrays, tables). They're enclosed in double angle brackets. Slices have three optional parameters delimited by .. \u2014 start , stop , and step . Slices can be either applied to indexable objects (like String or Array ) or serve as stand-alone objects. Iterating over a slice object generates integers from start (inclusive) to stop (exclusive) separated by gaps of size step . If start is not specified, it defaults to 0. If stop is not specified, it defaults to 2 63 - 1. If step is not specified, it defaults to 1. str: \"abcdefgh\"; str<<\\>> :: \"a\"; str<<//..//\\>> :: \"def\"; str<</..//\\../\\>> :: \"bdf\"; All valid slice parameters are as follows: Slice Returns <<>> the whole iterable <<index>> the item at position index <<..stop>> items up to index stop <<....step>> items separated by gaps of size step <<start..>> items starting from index start <<..stop..step>> items up to index stop separated by gaps of size step <<start....step>> items starting from index start separated by gaps of size step <<start..stop>> items starting from index start up to index stop <<start..stop..step>> items starting from index start up to index stop separated by gaps of size step","title":"Slices"},{"location":"slices/#slices","text":"Slices are used to access a range of items in an iterable (strings, arrays, tables). They're enclosed in double angle brackets. Slices have three optional parameters delimited by .. \u2014 start , stop , and step . Slices can be either applied to indexable objects (like String or Array ) or serve as stand-alone objects. Iterating over a slice object generates integers from start (inclusive) to stop (exclusive) separated by gaps of size step . If start is not specified, it defaults to 0. If stop is not specified, it defaults to 2 63 - 1. If step is not specified, it defaults to 1. str: \"abcdefgh\"; str<<\\>> :: \"a\"; str<<//..//\\>> :: \"def\"; str<</..//\\../\\>> :: \"bdf\"; All valid slice parameters are as follows: Slice Returns <<>> the whole iterable <<index>> the item at position index <<..stop>> items up to index stop <<....step>> items separated by gaps of size step <<start..>> items starting from index start <<..stop..step>> items up to index stop separated by gaps of size step <<start....step>> items starting from index start separated by gaps of size step <<start..stop>> items starting from index start up to index stop <<start..stop..step>> items starting from index start up to index stop separated by gaps of size step","title":"Slices"},{"location":"stdcollections/","text":"collections module The collections module implements a few different data structure classes: Stack , Queue , Set , Deque and StaticArray . Stack A stack is a collection of items that the user may \"push\" a new item on top of, or \"pop\" the most recently added/top item from, following a last in first out order (LIFO). Method Use create([size]) Initializes an empty Stack object with capacity size . If size is unspecified it will default to -1 , giving the stack unbounded capacity. is_empty() Returns 1 if the number of items in the stack is equal to 0, otherwise returns 0 . is_full() Returns 1 if the number of items in the stack is equal to the specified capacity, otherwise returns 0 . 1 peek() Returns the value of the item on top of the stack without popping it. If the stack is empty, this will instead throw an error. pop() Pops/removes an item from the top of the stack, and returns it. If the stack is empty, this will instead throw an error. push(item) Pushes item on top of the stack. If the stack is full, i.e. its size is equal to the specified capacity, this will instead throw an error. push_all(items) Pushes each element of items on top of the stack, one at a time. special() Returns the number of items in the stack. to_bit() Returns 1 if the stack is not empty, otherwise returns 0 . 2 to_string() Returns some information about the stack as a string; its capacity, number of items, and the value of the top item. Queue A queue is a collection of items that the user may \"put\" (\"enqueue\") an item at the back of, or \"get\" (\"dequeue\") an item from the front of, following a first in first out order (FIFO). Method Use create([size]) Initializes an empty Queue object with capacity size . If size is unspecified it will default to -1 , giving the queue unbounded capacity. first() Returns the value of the item at the front of the queue, without removing it. If the queue is empty, this will instead throw an error. get() Gets/removes an item from the front of the queue, and returns it. If the queue is empty, this will instead throw an error. is_empty() Returns 1 if the number of items in the queue is equal to 0, otherwise returns 0 . is_full() Returns 1 if the number of items in the queue is equal to the specified capacity, otherwise returns 0 . 1 last() Returns the value of the item at the back of the queue, without removing it. If the queue is empty, this will instead throw an error. put(item) Puts item at the back of the queue. If the queue is full, i.e. its size is equal to the specified capacity, this will instead throw an error. put_all(items) Puts each element of items at the back of the queue, one at a time. special() Returns the number of items in the queue. to_bit() Returns 1 if the queue is not empty, otherwise returns 0 . 2 to_string() Returns some information about the queue as a string; its capacity, number of items, and the values of its items. Note that if there are more than 5 items in the queue, the string will be truncated. Deque A deque is a data structure similar to a queue, but where insertion and removal of elements can be performed from both the front and the back. Method Use back() Returns the value of the item at the back of the deque, without removing it. If the deque is empty, this will instead throw an error. create([size]) Initializes an empty Deque object with capacity size . If size is unspecified it will default to -1 , giving the deque unbounded capacity. front() Returns the value of the item at the front of the deque, without removing it. If the deque is empty, this will instead throw an error. get() Gets/removes an item from the back of the deque, and returns it. If the deque is empty, this will instead throw an error. get_front() Gets/removes an item from the front of the deque, and returns it. If the deque is empty, this will instead throw an error. is_empty() Returns 1 if the number of items in the deque is equal to 0, otherwise returns 0 . is_full() Returns 1 if the number of items in the deque is equal to the specified capacity, otherwise returns 0 . 1 put(item) Puts item at the back of the deque. If the deque is full, i.e. its size is equal to the specified capacity, this will instead throw an error. put_all(items) Puts each element of items at the back of the deque, one at a time. put_front(item) Puts item at the front of the deque. If the deque is full, i.e. its size is equal to the specified capacity, this will instead throw an error. put_front_all(items) Puts each element of items at the front of the deque, one at a time. special() Returns the number of items in the deque. to_bit() Returns 1 if the deque is not empty, otherwise returns 0 . 2 to_string() Returns some information about the deque as a string; its capacity, number of items, and the values of its items. Note that if there are more than 5 items in the deque, the string will be truncated. Set A set is an unordered collection of items, with no duplicates. Method Use add(value) Adds value to the set, provided it doesn't already exist in the set, and returns a status code ( 0 or 1 ) based on whether it was added. If value isn't already in the set, and the set is full, i.e. its size is equal to the specified capacity, this will instead throw an error. clear() Removes every element from the set. create([items], [capacity]) Initializes a Set object, with its contents being items with any duplicate elements removed, and its capacity being capacity . If items is unspecified it will default to an empty array. If capacity is unspecified it will default to -1 , giving the set unbounded capacity. difference(other) Returns the difference of the current set and other , i.e. a new set containing all items that the current set contains but other does not. has(value) Returns 1 if value is contained in the set, otherwise returns 0 . intersection(other) Returns the intersection of the current set and other , i.e. a new set containing all items that the two sets share. is_empty() Returns 1 if the number of items in the set is equal to 0, otherwise returns 0 . is_full() Returns 1 if the number of items in the set is equal to the specified capacity, otherwise returns 0 . 1 is_subset(other) Returns 1 if the current set is a subset of other , i.e. every element of the current set is contained in other . remove(value) Removes value from the set, provided it exists in the set. special() Returns the number of items in the set. to_bit() Returns 1 if the deque is not empty, otherwise returns 0 . 2 to_string() Returns some information about the set as a string; its capacity, number of items, and the values of its items. union(other) Returns the union of the current set and other , i.e. the two sets' items added together with duplicates again removed. values() Returns the contents of the set as an array. StaticArray A static array is like a normal array, but with a fixed size. They may also enforce all elements to be of a certain type. Method Use create(value[, type]) Initializes a StaticArray object. If type is specified, it defines the enforced type of the static array. If value is an integer, it defines the size of the static array. If value is an array, its size defines the size of the static array, and its elements are copied into the static array. If type is not specified, the static array will not enforce elements to be of any particular type. get_item(index) Returns the index th item in the static array. If index is outside the bounds of the static array, an error is thrown. set_item(index, value) Sets the index th item in the static array to value . If index is outside the bounds of the static array, or value is not of the correct type for the array, provided it enforces a particular type, an error is thrown. special() Returns an array containing all items in the static array, with any unassigned indices ignored. to_bit() Returns 1 if the static array is not empty, otherwise returns 0 . to_string() Returns some information about the static array as a string; its size, its type (\"null\" if it doesn't enforce one), and a table mapping each item's index to its value. ArithmeticArray An arithmetic array is an array which can be used with different binary operators. <-collections.ArithmeticArray; aa: ArithmeticArray([/\\, //, /\\/]); aa!; == [2, 3, 5] aa + /\\!; == [4, 5, 7] aa ++ ///!; == [14, 21, 35] is_odd: aa --- /\\; is_odd!; == [0, 1, 1] aa: ArithmeticArray([\"oh\", \"hey\", \"hello\"]); aa + \"!\"!; == [\"oh!\", \"hey!\", \"hello!\"] Binary operators supported by ArithmeticArray: - arithmetic: + , ++ , +++ , - , -- , --- - bitwise: & , | , ^ - comparison: :: , >: , > , <: , < , ::: ArithmeticArray allows item assignment and inherits behavior for $ , to_bit , and to_string from the Array class. You can also use your own custom operators in the form of functions by using the apply(op, other) method: <-collections.ArithmeticArray; <-math.shl; aa: ArithmeticArray([///, /\\//, //\\/]); aa!; aa.apply(shl, /\\)!; remove_null nullable default * { * default ? nullable :: _ ,, nullable; } aa: ArithmeticArray([_, /\\, //, _, /\\/, _, ///]); aa!; == [null, 2, 3, null, 5, null, 7] aa.apply(remove_null, \\)!; == [0, 2, 3, 0, 5, 0, 7] Note that this will always return 0 if the specified capacity is negative, or if the user does not provide a capacity. \u21a9 \u21a9 \u21a9 \u21a9 to_bit() is functionally the opposite of is_empty() . \u21a9 \u21a9 \u21a9 \u21a9","title":"collections module"},{"location":"stdcollections/#collections-module","text":"The collections module implements a few different data structure classes: Stack , Queue , Set , Deque and StaticArray .","title":"collections module"},{"location":"stdcollections/#stack","text":"A stack is a collection of items that the user may \"push\" a new item on top of, or \"pop\" the most recently added/top item from, following a last in first out order (LIFO). Method Use create([size]) Initializes an empty Stack object with capacity size . If size is unspecified it will default to -1 , giving the stack unbounded capacity. is_empty() Returns 1 if the number of items in the stack is equal to 0, otherwise returns 0 . is_full() Returns 1 if the number of items in the stack is equal to the specified capacity, otherwise returns 0 . 1 peek() Returns the value of the item on top of the stack without popping it. If the stack is empty, this will instead throw an error. pop() Pops/removes an item from the top of the stack, and returns it. If the stack is empty, this will instead throw an error. push(item) Pushes item on top of the stack. If the stack is full, i.e. its size is equal to the specified capacity, this will instead throw an error. push_all(items) Pushes each element of items on top of the stack, one at a time. special() Returns the number of items in the stack. to_bit() Returns 1 if the stack is not empty, otherwise returns 0 . 2 to_string() Returns some information about the stack as a string; its capacity, number of items, and the value of the top item.","title":"Stack"},{"location":"stdcollections/#queue","text":"A queue is a collection of items that the user may \"put\" (\"enqueue\") an item at the back of, or \"get\" (\"dequeue\") an item from the front of, following a first in first out order (FIFO). Method Use create([size]) Initializes an empty Queue object with capacity size . If size is unspecified it will default to -1 , giving the queue unbounded capacity. first() Returns the value of the item at the front of the queue, without removing it. If the queue is empty, this will instead throw an error. get() Gets/removes an item from the front of the queue, and returns it. If the queue is empty, this will instead throw an error. is_empty() Returns 1 if the number of items in the queue is equal to 0, otherwise returns 0 . is_full() Returns 1 if the number of items in the queue is equal to the specified capacity, otherwise returns 0 . 1 last() Returns the value of the item at the back of the queue, without removing it. If the queue is empty, this will instead throw an error. put(item) Puts item at the back of the queue. If the queue is full, i.e. its size is equal to the specified capacity, this will instead throw an error. put_all(items) Puts each element of items at the back of the queue, one at a time. special() Returns the number of items in the queue. to_bit() Returns 1 if the queue is not empty, otherwise returns 0 . 2 to_string() Returns some information about the queue as a string; its capacity, number of items, and the values of its items. Note that if there are more than 5 items in the queue, the string will be truncated.","title":"Queue"},{"location":"stdcollections/#deque","text":"A deque is a data structure similar to a queue, but where insertion and removal of elements can be performed from both the front and the back. Method Use back() Returns the value of the item at the back of the deque, without removing it. If the deque is empty, this will instead throw an error. create([size]) Initializes an empty Deque object with capacity size . If size is unspecified it will default to -1 , giving the deque unbounded capacity. front() Returns the value of the item at the front of the deque, without removing it. If the deque is empty, this will instead throw an error. get() Gets/removes an item from the back of the deque, and returns it. If the deque is empty, this will instead throw an error. get_front() Gets/removes an item from the front of the deque, and returns it. If the deque is empty, this will instead throw an error. is_empty() Returns 1 if the number of items in the deque is equal to 0, otherwise returns 0 . is_full() Returns 1 if the number of items in the deque is equal to the specified capacity, otherwise returns 0 . 1 put(item) Puts item at the back of the deque. If the deque is full, i.e. its size is equal to the specified capacity, this will instead throw an error. put_all(items) Puts each element of items at the back of the deque, one at a time. put_front(item) Puts item at the front of the deque. If the deque is full, i.e. its size is equal to the specified capacity, this will instead throw an error. put_front_all(items) Puts each element of items at the front of the deque, one at a time. special() Returns the number of items in the deque. to_bit() Returns 1 if the deque is not empty, otherwise returns 0 . 2 to_string() Returns some information about the deque as a string; its capacity, number of items, and the values of its items. Note that if there are more than 5 items in the deque, the string will be truncated.","title":"Deque"},{"location":"stdcollections/#set","text":"A set is an unordered collection of items, with no duplicates. Method Use add(value) Adds value to the set, provided it doesn't already exist in the set, and returns a status code ( 0 or 1 ) based on whether it was added. If value isn't already in the set, and the set is full, i.e. its size is equal to the specified capacity, this will instead throw an error. clear() Removes every element from the set. create([items], [capacity]) Initializes a Set object, with its contents being items with any duplicate elements removed, and its capacity being capacity . If items is unspecified it will default to an empty array. If capacity is unspecified it will default to -1 , giving the set unbounded capacity. difference(other) Returns the difference of the current set and other , i.e. a new set containing all items that the current set contains but other does not. has(value) Returns 1 if value is contained in the set, otherwise returns 0 . intersection(other) Returns the intersection of the current set and other , i.e. a new set containing all items that the two sets share. is_empty() Returns 1 if the number of items in the set is equal to 0, otherwise returns 0 . is_full() Returns 1 if the number of items in the set is equal to the specified capacity, otherwise returns 0 . 1 is_subset(other) Returns 1 if the current set is a subset of other , i.e. every element of the current set is contained in other . remove(value) Removes value from the set, provided it exists in the set. special() Returns the number of items in the set. to_bit() Returns 1 if the deque is not empty, otherwise returns 0 . 2 to_string() Returns some information about the set as a string; its capacity, number of items, and the values of its items. union(other) Returns the union of the current set and other , i.e. the two sets' items added together with duplicates again removed. values() Returns the contents of the set as an array.","title":"Set"},{"location":"stdcollections/#staticarray","text":"A static array is like a normal array, but with a fixed size. They may also enforce all elements to be of a certain type. Method Use create(value[, type]) Initializes a StaticArray object. If type is specified, it defines the enforced type of the static array. If value is an integer, it defines the size of the static array. If value is an array, its size defines the size of the static array, and its elements are copied into the static array. If type is not specified, the static array will not enforce elements to be of any particular type. get_item(index) Returns the index th item in the static array. If index is outside the bounds of the static array, an error is thrown. set_item(index, value) Sets the index th item in the static array to value . If index is outside the bounds of the static array, or value is not of the correct type for the array, provided it enforces a particular type, an error is thrown. special() Returns an array containing all items in the static array, with any unassigned indices ignored. to_bit() Returns 1 if the static array is not empty, otherwise returns 0 . to_string() Returns some information about the static array as a string; its size, its type (\"null\" if it doesn't enforce one), and a table mapping each item's index to its value.","title":"StaticArray"},{"location":"stdcollections/#arithmeticarray","text":"An arithmetic array is an array which can be used with different binary operators. <-collections.ArithmeticArray; aa: ArithmeticArray([/\\, //, /\\/]); aa!; == [2, 3, 5] aa + /\\!; == [4, 5, 7] aa ++ ///!; == [14, 21, 35] is_odd: aa --- /\\; is_odd!; == [0, 1, 1] aa: ArithmeticArray([\"oh\", \"hey\", \"hello\"]); aa + \"!\"!; == [\"oh!\", \"hey!\", \"hello!\"] Binary operators supported by ArithmeticArray: - arithmetic: + , ++ , +++ , - , -- , --- - bitwise: & , | , ^ - comparison: :: , >: , > , <: , < , ::: ArithmeticArray allows item assignment and inherits behavior for $ , to_bit , and to_string from the Array class. You can also use your own custom operators in the form of functions by using the apply(op, other) method: <-collections.ArithmeticArray; <-math.shl; aa: ArithmeticArray([///, /\\//, //\\/]); aa!; aa.apply(shl, /\\)!; remove_null nullable default * { * default ? nullable :: _ ,, nullable; } aa: ArithmeticArray([_, /\\, //, _, /\\/, _, ///]); aa!; == [null, 2, 3, null, 5, null, 7] aa.apply(remove_null, \\)!; == [0, 2, 3, 0, 5, 0, 7] Note that this will always return 0 if the specified capacity is negative, or if the user does not provide a capacity. \u21a9 \u21a9 \u21a9 \u21a9 to_bit() is functionally the opposite of is_empty() . \u21a9 \u21a9 \u21a9 \u21a9","title":"ArithmeticArray"},{"location":"stddatetime/","text":"datetime module The datetime module consists of several functions that assist with date and time related tasks. Additionally, it includes two classes ( DateTime and DTDiff ). Variable Contents MONTHS [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"] WEEKDAYS [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"] Function Use sleep_seconds(seconds) Pauses execution for seconds seconds. sleep_minutes(minutes) Pauses execution for minutes minutes. is_leap_year(year) Returns 1 if the year is a leap year otherwise 0 . days_in_month(year, month) Returns the amount of days in a given month keeping in track leapyears. month_name(n) Gives the name of a numbered month where 1 is January . weekday_name(n) Gives the day of a week from a number where 1 is a Monday and 7 is Sunday . timestamp_utc([ts]) Yields the UTC timestamp using the provided timestamp or current time. DateTime Method Use subtract(other) Subtract two DateTime objects, returns a DTDiff object. to_string Return the date and time in the format Y-M-D h:m:s.z . to_timestamp Returns the time in Unix Time milliseconds. Special Methods \u21a9","title":"datetime module"},{"location":"stddatetime/#datetime-module","text":"The datetime module consists of several functions that assist with date and time related tasks. Additionally, it includes two classes ( DateTime and DTDiff ). Variable Contents MONTHS [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"] WEEKDAYS [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"] Function Use sleep_seconds(seconds) Pauses execution for seconds seconds. sleep_minutes(minutes) Pauses execution for minutes minutes. is_leap_year(year) Returns 1 if the year is a leap year otherwise 0 . days_in_month(year, month) Returns the amount of days in a given month keeping in track leapyears. month_name(n) Gives the name of a numbered month where 1 is January . weekday_name(n) Gives the day of a week from a number where 1 is a Monday and 7 is Sunday . timestamp_utc([ts]) Yields the UTC timestamp using the provided timestamp or current time.","title":"datetime module"},{"location":"stddatetime/#datetime","text":"Method Use subtract(other) Subtract two DateTime objects, returns a DTDiff object. to_string Return the date and time in the format Y-M-D h:m:s.z . to_timestamp Returns the time in Unix Time milliseconds. Special Methods \u21a9","title":"DateTime"},{"location":"stditer/","text":"iter module The iter module contains several functions that interact with iterable objects, like strings or arrays. Function Use accumulate(array, function) Yields accumulated applications of function 2 on consecutive elements of array . If for example function returned the sum of both of its arguments, then accumulate([/, /\\, //, /\\\\, /\\/], function) would yield 1 , 3 , 6 , 10 , and 15 . all(array) Returns 1 if all elements of array are truthy, 0 otherwise. Returns 1 for empty arrays. any(array) Returns 1 if any of the elements of array is truthy, 0 otherwise. Returns 0 for empty arrays. chunks(array, size) Iterates over array in chunks of size size . When array 's length is not evenly divided by size , the last slice of array will be the remainder. count(array, target) Returns the number of times target appears in array . drop_while(array, function) Evaluates function 1 on each item of array , and yields elements of array starting from the first item (from the left) for which function returns a falsy value. enumerate(array) Yields elements of array but with each item as a length 2 array containing the item's index paired with the original item. filter(array, function) Evaluates function 1 on each item of array , and yields those items that cause function to return a truthy value. filter_false(array, function) Evaluates function 1 on each item of array , and yields those items that cause function to return a falsy value. find(array, target) Finds the first instance of target in array , and returns its index. array may be of type Array or String. If target does not appear in array , -1 is returned instead. find_all(array, target) Finds all instances of target in array , and yields their indices. flatten(array[, depth]) Flattens array depth times. By default, flattens recursively as deep as possible. map(array, function) Applies function 1 to each item of array , and yields those new values. pairwise(array) Yields successive overlapping pairs taken from array . reduce(array, function) Applies function 2 cumulatively to consecutive items of array , reducing it to a single value, then returns this value. Equivalent to [i ... i ->? accumulate(array, function)]<<-/>> . reverse(array) Yields the items of array in reverse order. sorted(array[, key]) Returns a sorted copy of array . The optional parameter key specifies a function 1 that is used to extract a comparison key from each element in array . Elements are compared directly by default. take_while(array, function) Evaluates function 1 on each item of array , and yields elements of array that is cut off at the first item (from the left) for which function returns a falsy value. zip(arrays) Iterates over several iterables in parallel, producing arrays with an item from each one. zip_longest(fill, arrays...) Iterates over several arrays, producing a set of arrays containing an item from each original array. If the arrays are of uneven length, missing values are filled using the fill argument. Note that function must take only one argument (excluding optional parameters). \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Note that function must take exactly two arguments (excluding optional parameters). \u21a9 \u21a9","title":"iter module"},{"location":"stditer/#iter-module","text":"The iter module contains several functions that interact with iterable objects, like strings or arrays. Function Use accumulate(array, function) Yields accumulated applications of function 2 on consecutive elements of array . If for example function returned the sum of both of its arguments, then accumulate([/, /\\, //, /\\\\, /\\/], function) would yield 1 , 3 , 6 , 10 , and 15 . all(array) Returns 1 if all elements of array are truthy, 0 otherwise. Returns 1 for empty arrays. any(array) Returns 1 if any of the elements of array is truthy, 0 otherwise. Returns 0 for empty arrays. chunks(array, size) Iterates over array in chunks of size size . When array 's length is not evenly divided by size , the last slice of array will be the remainder. count(array, target) Returns the number of times target appears in array . drop_while(array, function) Evaluates function 1 on each item of array , and yields elements of array starting from the first item (from the left) for which function returns a falsy value. enumerate(array) Yields elements of array but with each item as a length 2 array containing the item's index paired with the original item. filter(array, function) Evaluates function 1 on each item of array , and yields those items that cause function to return a truthy value. filter_false(array, function) Evaluates function 1 on each item of array , and yields those items that cause function to return a falsy value. find(array, target) Finds the first instance of target in array , and returns its index. array may be of type Array or String. If target does not appear in array , -1 is returned instead. find_all(array, target) Finds all instances of target in array , and yields their indices. flatten(array[, depth]) Flattens array depth times. By default, flattens recursively as deep as possible. map(array, function) Applies function 1 to each item of array , and yields those new values. pairwise(array) Yields successive overlapping pairs taken from array . reduce(array, function) Applies function 2 cumulatively to consecutive items of array , reducing it to a single value, then returns this value. Equivalent to [i ... i ->? accumulate(array, function)]<<-/>> . reverse(array) Yields the items of array in reverse order. sorted(array[, key]) Returns a sorted copy of array . The optional parameter key specifies a function 1 that is used to extract a comparison key from each element in array . Elements are compared directly by default. take_while(array, function) Evaluates function 1 on each item of array , and yields elements of array that is cut off at the first item (from the left) for which function returns a falsy value. zip(arrays) Iterates over several iterables in parallel, producing arrays with an item from each one. zip_longest(fill, arrays...) Iterates over several arrays, producing a set of arrays containing an item from each original array. If the arrays are of uneven length, missing values are filled using the fill argument. Note that function must take only one argument (excluding optional parameters). \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Note that function must take exactly two arguments (excluding optional parameters). \u21a9 \u21a9","title":"iter module"},{"location":"stdmath/","text":"math module The math module provides access to a set of commonly used mathematical functions. Function Use abs(n) Returns the absolute value of n . factorial(n) Returns n factorial. gcd(a, b) Returns the greatest common divisor of a and b . If either argument is zero, the absolute value of the other argument will be returned. is_prime(n) Returns 1 if n is prime, 0 otherwise. lcm(a, b) Returns the least common multiple of a and b . If any of the arguments is zero, then the returned value is 0 . max(array) Returns the largest integer in array . min(array) Returns the smallest integer in array . product(array) Multiplies the items of array from left to right and returns the total. The array 's items must be integers. shl(a, b) Returns a shifted to the left by b bits. shr(a, b) Returns a shifted to the right by b bits. sqrt(n) Returns the integer square root of the nonnegative integer n . This is the floor of the exact square root of n . sum(array) Sums the items of array from left to right and returns the total. The array 's items must be integers.","title":"math module"},{"location":"stdmath/#math-module","text":"The math module provides access to a set of commonly used mathematical functions. Function Use abs(n) Returns the absolute value of n . factorial(n) Returns n factorial. gcd(a, b) Returns the greatest common divisor of a and b . If either argument is zero, the absolute value of the other argument will be returned. is_prime(n) Returns 1 if n is prime, 0 otherwise. lcm(a, b) Returns the least common multiple of a and b . If any of the arguments is zero, then the returned value is 0 . max(array) Returns the largest integer in array . min(array) Returns the smallest integer in array . product(array) Multiplies the items of array from left to right and returns the total. The array 's items must be integers. shl(a, b) Returns a shifted to the left by b bits. shr(a, b) Returns a shifted to the right by b bits. sqrt(n) Returns the integer square root of the nonnegative integer n . This is the floor of the exact square root of n . sum(array) Sums the items of array from left to right and returns the total. The array 's items must be integers.","title":"math module"},{"location":"stdoperator/","text":"operator module This module contains a set of functions corresponding to the native operators of Samarium. For instance, operator.mul(a, b) is equivalent to a ++ b . Each of the function names can be used for defining special methods in classes. Function Operator add(x, y) x + y and(x, y) x & y cast(x) x% divide(x, y) x -- y equals(x, y) x :: y greater_than(x, y) x > y greater_than_or_equal(x, y) x >: y has(x, y) y ->? x hash(x) x## less_than(x, y) x < y less_than_or_equal(x, y) x <: y mod(x, y) x --- y multiply(x, y) x ++ y not(x) ~x not_equals(x, y) x ::: y or(x, y) x | y power(x, y) x +++ y random(x) x?? special(x) x$ subtract(x, y) x - y to_bit(x) x.to_bit() to_string(x) x.to_string() xor(x, y) x ^ y","title":"operator module"},{"location":"stdoperator/#operator-module","text":"This module contains a set of functions corresponding to the native operators of Samarium. For instance, operator.mul(a, b) is equivalent to a ++ b . Each of the function names can be used for defining special methods in classes. Function Operator add(x, y) x + y and(x, y) x & y cast(x) x% divide(x, y) x -- y equals(x, y) x :: y greater_than(x, y) x > y greater_than_or_equal(x, y) x >: y has(x, y) y ->? x hash(x) x## less_than(x, y) x < y less_than_or_equal(x, y) x <: y mod(x, y) x --- y multiply(x, y) x ++ y not(x) ~x not_equals(x, y) x ::: y or(x, y) x | y power(x, y) x +++ y random(x) x?? special(x) x$ subtract(x, y) x - y to_bit(x) x.to_bit() to_string(x) x.to_string() xor(x, y) x ^ y","title":"operator module"},{"location":"stdrandom/","text":"random module The random module implements functions that make use of the random method ?? . Function Use choices(iter, k) Randomly selects an item from iter k times and returns the resulting choices as an array. randint(a, b) Returns a random integer in range [a, b]. sample(array, k) Randomly selects k unique items from array , and returns the resulting choices as an array. shuffle(array) Randomly shuffles array and returns the result. array must be of type Array.","title":"random module"},{"location":"stdrandom/#random-module","text":"The random module implements functions that make use of the random method ?? . Function Use choices(iter, k) Randomly selects an item from iter k times and returns the resulting choices as an array. randint(a, b) Returns a random integer in range [a, b]. sample(array, k) Randomly selects k unique items from array , and returns the resulting choices as an array. shuffle(array) Randomly shuffles array and returns the result. array must be of type Array.","title":"random module"},{"location":"stdstring/","text":"string module The string module contains several useful functions for string manipulation, as well as some variables containing groups of similar characters. Variable Contents DIGITS \"0123456789\" HEXDIGITS \"0123456789abcdef\" LETTERS UPPERCASE + LOWERCASE LOWERCASE \"abcdefghijklmnopqrstuvwxyz\" OCTDIGITS \"01234567\" PRINTABLE LETTERS + DIGITS + PUNCTUATION + WHITESPACE PUNCTUATION \"!\\\"#$%&'()*+,-./:;<=>?@[]^_`{\\|}~\" UPPERCASE \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" WHITESPACE \" \\t\\n\\r\\f\\v\" Function Use capitalize(string) Returns a copy of string with the first character set to uppercase (assuming it's a cased character 2 ) and all subsequent character set to lowercase. center(string, length[, char]) 1 Returns string centered in a new string of length length , padded using the specified char . If char is not specified, it defaults to \" \" (space). string is returned unchanged if length is less than or equal to the length of string . ends_with(string, suffix) Returns 1 if string ends with the substring suffix , otherwise returns 0 . format(string, fields) Replaces field placeholders with supplied values, e.g.: format(\"Hi $name!\", {{\"name\" -> \"Bob\"}}) :: \"Hi Bob!\" format(\"$$age = $age\", {{\"age\" -> /\\\\}}) :: \"$age = 4\" When provided with an Array instead of a Table, the indeces of specific values serve as keys: format(\"{$0@$1}\", [\"host\", \"home\"]) :: \"{host@home}\" is_alphabetic(string) Returns 1 if every character in string is an alphabetic character, i.e. is contained in the string letters , otherwise returns 0 . is_alphanumeric(string) Returns 1 if every character in string is an alphanumeric character, i.e. is contained in the strings letters or numbers , otherwise returns 0 . is_capitalized(string) Returns 1 if string is capitalized, i.e. matches the output of capitalize(string) exactly. is_decimal(string) Returns 1 if every character in string is a decimal digit, i.e. is contained in the string DIGITS , otherwise returns 0 . is_hexadecimal(string) Returns 1 if every character in string is a hexadecimal digit, i.e. is contained in the string HEXDIGITS , otherwise returns 0 . is_in_group(string, group) Returns 1 if every character in string is in the specified group of type Array or String, otherwise returns 0 . is_lower(string) Returns 1 if every cased character 2 in string is lowercase, otherwise returns 0 . is_octal(string) Returns 1 if every character in string is an octal digit, i.e. is contained in the string OCTDIGITS , otherwise returns 0 . is_title(string) Returns 1 if string is in title case, i.e. matches the output of title(string) exactly. is_upper(string) Returns 1 if every cased character 2 in string is uppercase, otherwise returns 0 . is_wrapped(string, chars) Returns 1 if string both starts and ends with the substring chars , otherwise returns 0 . join(iterable[, delimiter]) Returns a string with each consecutive member of iterable converted to a string and joined with delimiter between them. If delimiter is not specified, it defaults to \" \" . leftpad(string, length[, char]) Returns a copy of string padded on the left so that it's length characters long, using char for padding. If char is not specified, it defaults to \" \" . If length is shorter than string 's length, a copy of string is returned. replace(string, replacement[, count]) Returns a copy of string , with all instances of each key in the replacement table replaced with its corresponding value. If count is specified, only the first count instances of each key will be replaced, starting from the left. rightpad(string, length[, char]) Returns a copy of string padded on the right so that it's length characters long, using char for padding. If char is not specified, it defaults to \" \" . If length is shorter than string 's length, a copy of string is returned. split(string[, delimiter]) Returns an array of the words in string , separated by delimiter . If delimiter is not specified, it defaults to \" \" . starts_with(string, prefix) Returns 1 if string starts with the substring prefix , otherwise returns 0 . strip(string, chars) Returns a copy of string with chars removed from both the beginning and the end, as in strip_left and strip_right . strip_left(string, prefix) Returns a copy of string with prefix removed from the beginning, multiple times if string still begins with prefix . If string doesn't begin with prefix , a copy of the original string is returned. strip_right(string, suffix) Returns a copy of string with suffix removed from the end, multiple times if string still ends with suffix . If string doesn't end with suffix , a copy of the original string is returned. swapcase(string) Returns a copy of string with every cased character 2 set to the opposite of its original case. title(string) Returns a copy of string with the first character of each word (separated by spaces) set to uppercase (assuming they're cased characters 2 ), and all subsequent characters of each word set to lowercase. to_lower(string) Returns a copy of string with every cased character 2 set to lowercase. to_upper(string) Returns a copy of string with every cased character 2 set to uppercase. wrap(string, wrapper) Returns a copy of string with wrapper added to the start and end. An argument in [square brackets] means that it has a default value, and so it isn't necessary to give it a value. \u21a9 Cased characters are alphabetic characters in either uppercase or lowercase; LETTERS is a string of all cased characters. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"string module"},{"location":"stdstring/#string-module","text":"The string module contains several useful functions for string manipulation, as well as some variables containing groups of similar characters. Variable Contents DIGITS \"0123456789\" HEXDIGITS \"0123456789abcdef\" LETTERS UPPERCASE + LOWERCASE LOWERCASE \"abcdefghijklmnopqrstuvwxyz\" OCTDIGITS \"01234567\" PRINTABLE LETTERS + DIGITS + PUNCTUATION + WHITESPACE PUNCTUATION \"!\\\"#$%&'()*+,-./:;<=>?@[]^_`{\\|}~\" UPPERCASE \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" WHITESPACE \" \\t\\n\\r\\f\\v\" Function Use capitalize(string) Returns a copy of string with the first character set to uppercase (assuming it's a cased character 2 ) and all subsequent character set to lowercase. center(string, length[, char]) 1 Returns string centered in a new string of length length , padded using the specified char . If char is not specified, it defaults to \" \" (space). string is returned unchanged if length is less than or equal to the length of string . ends_with(string, suffix) Returns 1 if string ends with the substring suffix , otherwise returns 0 . format(string, fields) Replaces field placeholders with supplied values, e.g.: format(\"Hi $name!\", {{\"name\" -> \"Bob\"}}) :: \"Hi Bob!\" format(\"$$age = $age\", {{\"age\" -> /\\\\}}) :: \"$age = 4\" When provided with an Array instead of a Table, the indeces of specific values serve as keys: format(\"{$0@$1}\", [\"host\", \"home\"]) :: \"{host@home}\" is_alphabetic(string) Returns 1 if every character in string is an alphabetic character, i.e. is contained in the string letters , otherwise returns 0 . is_alphanumeric(string) Returns 1 if every character in string is an alphanumeric character, i.e. is contained in the strings letters or numbers , otherwise returns 0 . is_capitalized(string) Returns 1 if string is capitalized, i.e. matches the output of capitalize(string) exactly. is_decimal(string) Returns 1 if every character in string is a decimal digit, i.e. is contained in the string DIGITS , otherwise returns 0 . is_hexadecimal(string) Returns 1 if every character in string is a hexadecimal digit, i.e. is contained in the string HEXDIGITS , otherwise returns 0 . is_in_group(string, group) Returns 1 if every character in string is in the specified group of type Array or String, otherwise returns 0 . is_lower(string) Returns 1 if every cased character 2 in string is lowercase, otherwise returns 0 . is_octal(string) Returns 1 if every character in string is an octal digit, i.e. is contained in the string OCTDIGITS , otherwise returns 0 . is_title(string) Returns 1 if string is in title case, i.e. matches the output of title(string) exactly. is_upper(string) Returns 1 if every cased character 2 in string is uppercase, otherwise returns 0 . is_wrapped(string, chars) Returns 1 if string both starts and ends with the substring chars , otherwise returns 0 . join(iterable[, delimiter]) Returns a string with each consecutive member of iterable converted to a string and joined with delimiter between them. If delimiter is not specified, it defaults to \" \" . leftpad(string, length[, char]) Returns a copy of string padded on the left so that it's length characters long, using char for padding. If char is not specified, it defaults to \" \" . If length is shorter than string 's length, a copy of string is returned. replace(string, replacement[, count]) Returns a copy of string , with all instances of each key in the replacement table replaced with its corresponding value. If count is specified, only the first count instances of each key will be replaced, starting from the left. rightpad(string, length[, char]) Returns a copy of string padded on the right so that it's length characters long, using char for padding. If char is not specified, it defaults to \" \" . If length is shorter than string 's length, a copy of string is returned. split(string[, delimiter]) Returns an array of the words in string , separated by delimiter . If delimiter is not specified, it defaults to \" \" . starts_with(string, prefix) Returns 1 if string starts with the substring prefix , otherwise returns 0 . strip(string, chars) Returns a copy of string with chars removed from both the beginning and the end, as in strip_left and strip_right . strip_left(string, prefix) Returns a copy of string with prefix removed from the beginning, multiple times if string still begins with prefix . If string doesn't begin with prefix , a copy of the original string is returned. strip_right(string, suffix) Returns a copy of string with suffix removed from the end, multiple times if string still ends with suffix . If string doesn't end with suffix , a copy of the original string is returned. swapcase(string) Returns a copy of string with every cased character 2 set to the opposite of its original case. title(string) Returns a copy of string with the first character of each word (separated by spaces) set to uppercase (assuming they're cased characters 2 ), and all subsequent characters of each word set to lowercase. to_lower(string) Returns a copy of string with every cased character 2 set to lowercase. to_upper(string) Returns a copy of string with every cased character 2 set to uppercase. wrap(string, wrapper) Returns a copy of string with wrapper added to the start and end. An argument in [square brackets] means that it has a default value, and so it isn't necessary to give it a value. \u21a9 Cased characters are alphabetic characters in either uppercase or lowercase; LETTERS is a string of all cased characters. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"string module"},{"location":"stdtypes/","text":"types module The types module implements native data type aliases and data types not built-in to the language itself. Additional types Boolean The Boolean type can have value either true or false . Booleans can be initialized with either a string with the value \"true\" or \"false\" , or a truthy/falsy value. Booleans support several operations: all comparison operations, all arithmetic operations, all bitwise operations, and can be used with logical operators, and converted to a string (specifically either \"true\" or \"false\" ). UUID4 Generates a random UUID, version 4. Returns a UUID object with attributes hex and dec : <-types.UUID4; uuid: UUID4(); uuid!; == 8b46f521-b821-4010-ae8f-9ae9522d9889 uuid.hex!; == 8b46f521b8214010ae8f9ae9522d9889 uuid.dec!; == 185131124056068440795959350641466120329 Built-in type aliases Array The Array type alias is defined to be equal to []?! . Caling Array() with no arguments will return an empty array. A copy of an array a can be made by using Array(a) . a: [/, /\\, //]; b: a; c: Array(a); d: a<<>>; a<</\\>>: /\\\\; a, b, c, d!; Arrays can also be constructed from strings and tables: Array(\"ball\") is equivalent to [\"b\", \"a\", \"l\", \"l\"] Array({{// -> /\\\\/, \"X\" -> \"D\" }}) is equivalent to [[//, /\\\\/], [\"X\", \"D\"]] Integer The Integer type alias is defined to be equal to \\?! . Caling Integer() with no arguments will return the integer 0 . Integers can be constructed from strings, including binary, octal, and hexadecimal representations: Integer(\"1000\") will return 1000 Integer(\"b:1000\") will return 8 Integer(\"o:1000\") will return 512 Integer(\"x:1000\") will return 4096 Null The Null type alias is defined to be equal to [,]<<\\>>?! . It can be used to explicitly use null values instead of relying on implicit null triggers. Slice The Slice type alias is defined to be equal to <<>>?! . Different slices can be constructed by using integers and nulls: Slice(/, /\\, //) is equivalent to <<!--../\\..//-->> Slice(, , -/) is equivalent to <<....-/>> Slice(/, , ,) is equivalent to <<!--..-->> Slice(, /\\/, ,) is equivalent to <<../\\/>> String The String type alias is defined to be equal to \"\"?! . Calling String() with no arguments will return an empty string. Any data type can be converted to a string. A copy of a string s can be made by using String(s) . Table The Table type alias is defined to be equal to {{}}?! . Calling Table() with no arguments will return an empty table. Tables can be constructed from arrays containing 2-element iterables: Table([[//, /\\\\/], \"XD\"]) is equivalent to {{// -> /\\\\/, \"X\" -> \"D\"}}","title":"types module"},{"location":"stdtypes/#types-module","text":"The types module implements native data type aliases and data types not built-in to the language itself.","title":"types module"},{"location":"stdtypes/#additional-types","text":"","title":"Additional types"},{"location":"stdtypes/#boolean","text":"The Boolean type can have value either true or false . Booleans can be initialized with either a string with the value \"true\" or \"false\" , or a truthy/falsy value. Booleans support several operations: all comparison operations, all arithmetic operations, all bitwise operations, and can be used with logical operators, and converted to a string (specifically either \"true\" or \"false\" ).","title":"Boolean"},{"location":"stdtypes/#uuid4","text":"Generates a random UUID, version 4. Returns a UUID object with attributes hex and dec : <-types.UUID4; uuid: UUID4(); uuid!; == 8b46f521-b821-4010-ae8f-9ae9522d9889 uuid.hex!; == 8b46f521b8214010ae8f9ae9522d9889 uuid.dec!; == 185131124056068440795959350641466120329","title":"UUID4"},{"location":"stdtypes/#built-in-type-aliases","text":"","title":"Built-in type aliases"},{"location":"stdtypes/#array","text":"The Array type alias is defined to be equal to []?! . Caling Array() with no arguments will return an empty array. A copy of an array a can be made by using Array(a) . a: [/, /\\, //]; b: a; c: Array(a); d: a<<>>; a<</\\>>: /\\\\; a, b, c, d!; Arrays can also be constructed from strings and tables: Array(\"ball\") is equivalent to [\"b\", \"a\", \"l\", \"l\"] Array({{// -> /\\\\/, \"X\" -> \"D\" }}) is equivalent to [[//, /\\\\/], [\"X\", \"D\"]]","title":"Array"},{"location":"stdtypes/#integer","text":"The Integer type alias is defined to be equal to \\?! . Caling Integer() with no arguments will return the integer 0 . Integers can be constructed from strings, including binary, octal, and hexadecimal representations: Integer(\"1000\") will return 1000 Integer(\"b:1000\") will return 8 Integer(\"o:1000\") will return 512 Integer(\"x:1000\") will return 4096","title":"Integer"},{"location":"stdtypes/#null","text":"The Null type alias is defined to be equal to [,]<<\\>>?! . It can be used to explicitly use null values instead of relying on implicit null triggers.","title":"Null"},{"location":"stdtypes/#slice","text":"The Slice type alias is defined to be equal to <<>>?! . Different slices can be constructed by using integers and nulls: Slice(/, /\\, //) is equivalent to <<!--../\\..//-->> Slice(, , -/) is equivalent to <<....-/>> Slice(/, , ,) is equivalent to <<!--..-->> Slice(, /\\/, ,) is equivalent to <<../\\/>>","title":"Slice"},{"location":"stdtypes/#string","text":"The String type alias is defined to be equal to \"\"?! . Calling String() with no arguments will return an empty string. Any data type can be converted to a string. A copy of a string s can be made by using String(s) .","title":"String"},{"location":"stdtypes/#table","text":"The Table type alias is defined to be equal to {{}}?! . Calling Table() with no arguments will return an empty table. Tables can be constructed from arrays containing 2-element iterables: Table([[//, /\\\\/], \"XD\"]) is equivalent to {{// -> /\\\\/, \"X\" -> \"D\"}}","title":"Table"},{"location":"strings/","text":"Strings Strings are defined using double quotation marks: str: \"Hello!\"; Multiline strings do not require any additional syntax: \"This is a multiline string\" Strings can be manipulated using some arithmetic operators: \"hello\" + \"world\" is the same as \"helloworld\" \"hello\" ++ // is the same as \"hellohellohello\"","title":"Strings"},{"location":"strings/#strings","text":"Strings are defined using double quotation marks: str: \"Hello!\"; Multiline strings do not require any additional syntax: \"This is a multiline string\" Strings can be manipulated using some arithmetic operators: \"hello\" + \"world\" is the same as \"helloworld\" \"hello\" ++ // is the same as \"hellohellohello\"","title":"Strings"},{"location":"tables/","text":"Tables Tables map hashable values to arbitrary objects. They are defined using double curly brackets, with -> mapping each key to each value: tab: {{\"key\" -> \"value\", / -> [/\\, \"a\"]}}; A table may be indexed by its keys, which will return their corresponding values, for example, from the previous table: tab<<\"key\">> returns \"value\" tab<</>> returns [2, \"a\"] After its initialization, the items of a table can be set using this indexing syntax. If the key doesn't already exist in the table, it will be created. tab<<\"key\">>: \"newvalue\" will overwrite the previous value of tab<<\"key\">> . tab<<\"newkey\">>: //\\ will create a new item in the table, with key \"newkey\" and value 6 . Tables can be merged together with the addition operator + . The values of the table to the right of the operator take priority when both tables share keys. Items can be removed from a table by key using the subtraction operator - : {{\"a\" -> /, \"b\" -> /\\, // -> /\\//}} - \"b\" gives {{\"a\" -> /, // -> /\\//}}","title":"Tables"},{"location":"tables/#tables","text":"Tables map hashable values to arbitrary objects. They are defined using double curly brackets, with -> mapping each key to each value: tab: {{\"key\" -> \"value\", / -> [/\\, \"a\"]}}; A table may be indexed by its keys, which will return their corresponding values, for example, from the previous table: tab<<\"key\">> returns \"value\" tab<</>> returns [2, \"a\"] After its initialization, the items of a table can be set using this indexing syntax. If the key doesn't already exist in the table, it will be created. tab<<\"key\">>: \"newvalue\" will overwrite the previous value of tab<<\"key\">> . tab<<\"newkey\">>: //\\ will create a new item in the table, with key \"newkey\" and value 6 . Tables can be merged together with the addition operator + . The values of the table to the right of the operator take priority when both tables share keys. Items can be removed from a table by key using the subtraction operator - : {{\"a\" -> /, \"b\" -> /\\, // -> /\\//}} - \"b\" gives {{\"a\" -> /, // -> /\\//}}","title":"Tables"},{"location":"tools/","text":"Shebang You can easily use your Samarium scripts on Unix by putting an appropriate shebang line at the top of your program, for instance #!/usr/bin/env samarium => * { \"Hi!\"!; } and making it executable, e.g. with $ chmod +x script Samarium REPL If you run the samarium command without any other arguments, you'll launch the REPL, an interactive shell that will read and evaluate any Samarium code you enter. $ samarium Samarium 0.3.1 ==> Interacting with the REPL is a nice way to experiment with Samarium: ==> / + /\\! 3 ==> 1: \"ball\"##! 1083481267058749873 ==> 1??! 443527852557841359 ==> 1??! 894622914084910886 The REPL also supports compound statements: ==> x: /\\/\\?? ==> ? x --- /\\ :: \\ { > x -- /\\!; > } ,, { > 3 ++ x + /!; > } 4 ==> x! 8","title":"Tools"},{"location":"tools/#shebang","text":"You can easily use your Samarium scripts on Unix by putting an appropriate shebang line at the top of your program, for instance #!/usr/bin/env samarium => * { \"Hi!\"!; } and making it executable, e.g. with $ chmod +x script","title":"Shebang"},{"location":"tools/#samarium-repl","text":"If you run the samarium command without any other arguments, you'll launch the REPL, an interactive shell that will read and evaluate any Samarium code you enter. $ samarium Samarium 0.3.1 ==> Interacting with the REPL is a nice way to experiment with Samarium: ==> / + /\\! 3 ==> 1: \"ball\"##! 1083481267058749873 ==> 1??! 443527852557841359 ==> 1??! 894622914084910886 The REPL also supports compound statements: ==> x: /\\/\\?? ==> ? x --- /\\ :: \\ { > x -- /\\!; > } ,, { > 3 ++ x + /!; > } 4 ==> x! 8","title":"Samarium REPL"},{"location":"variables/","text":"Variables Variables are defined using the assignment operator : , like so: my_var: /; Variables can have many types, such as integers, strings, arrays, tables, slices, or null. Functions and classes may also be treated as first-class variables. Only letters, numbers, and underscores can be used for variable names (case sensitive). Note Samarium follows the same naming convention as Python, i.e.: \u2014 snake_case for variables and functions \u2014 PascalCase for classes and type aliases \u2014 flatcase for modules Variables can be made private by prefixing the name with # , making them inaccessible to external modules. Private variable names don't collide with public variable names: var: -/; #var: /; var!; == -1 #var!; == 1 Main Function The main function/entrypoint of the program is denoted by => . This function will be implicitly called on execution of the program. The return value of the main function indicates the exit code of the program (optional, defaults to 0). Attempts to write to stdout outside the scope of this or any other function will be ignored. Command line arguments can be gotten as an array with an optional parameter in this function. => argv * { == program here }","title":"Variables"},{"location":"variables/#variables","text":"Variables are defined using the assignment operator : , like so: my_var: /; Variables can have many types, such as integers, strings, arrays, tables, slices, or null. Functions and classes may also be treated as first-class variables. Only letters, numbers, and underscores can be used for variable names (case sensitive). Note Samarium follows the same naming convention as Python, i.e.: \u2014 snake_case for variables and functions \u2014 PascalCase for classes and type aliases \u2014 flatcase for modules Variables can be made private by prefixing the name with # , making them inaccessible to external modules. Private variable names don't collide with public variable names: var: -/; #var: /; var!; == -1 #var!; == 1","title":"Variables"},{"location":"variables/#main-function","text":"The main function/entrypoint of the program is denoted by => . This function will be implicitly called on execution of the program. The return value of the main function indicates the exit code of the program (optional, defaults to 0). Attempts to write to stdout outside the scope of this or any other function will be ignored. Command line arguments can be gotten as an array with an optional parameter in this function. => argv * { == program here }","title":"Main Function"}]}